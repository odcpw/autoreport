### SHEET/WORKBOOK CODE: ThisWorkbook
==================================================
--------------------------------------------------

### SHEET/WORKBOOK CODE: Sheet1
==================================================
--------------------------------------------------

### FORM CODE: PhotoSorterForm
==================================================
Dim imageFiles As Collection
Dim imagesLoadedFlag As Boolean
Private currentIndex As Long
Private currentImageName As String
Private buttonCollection As Collection
Public existingButtonCaptions As Scripting.Dictionary

Private Sub UserForm_Initialize()
    PhotoSorterForm_Initialize
End Sub
Public Sub PhotoSorterForm_Initialize()
    Set imageFiles = New Collection
    Me.Top = 0
    InitializeSubDirectoryNames
    
    ' Initialize lblImageCounts
    lblImageCounts.caption = "Total Images: 0, Unsorted Images: 0"
    
    imagesLoadedFlag = False
    ' Populate cmbFilter
    With cmbFilter
        .AddItem "Show All"
        .AddItem "Show Only Unsorted"
        .AddItem "Show Only Sorted"
        .ListIndex = 0 ' Set default to "Show All"
    End With
End Sub

Private Sub cmbFilter_Change()
    If imagesLoadedFlag Then
        FilterAndReloadImages
    End If
    InvisibleTextBox.SetFocus
End Sub

Private Sub FilterAndReloadImages()
    Dim ws As Worksheet
    Dim lastRow As Long
    Dim unsortedCol As Range
    Dim filterOption As String
    Dim rowIndex As Long
    Dim imagePath As String
    Dim fileName As String
    Dim categoryCol As Range
    Dim isSorted As Boolean

    Set ws = ThisWorkbook.Sheets("PSHelperSheet")
    filterOption = cmbFilter.Value
    lastRow = ws.Cells(ws.Rows.Count, 1).End(xlUp).row
    Set unsortedCol = ws.Rows(1).Find(What:="Unsorted", LookIn:=xlValues, LookAt:=xlWhole)

    ' Clear the current imageFiles collection
    Set imageFiles = New Collection

    ' Debugging message
    Debug.Print "Filter option selected: " & filterOption

    ' Loop through the helper sheet to load images based on the filter option
    For rowIndex = 2 To lastRow ' Assuming the first row is headers
        fileName = ws.Cells(rowIndex, 1).Value
        imagePath = rootPath & "\" & fileName
        
        If filterOption = "Show All" Then
            imageFiles.Add imagePath
        ElseIf filterOption = "Show Only Unsorted" Then
            If Not unsortedCol Is Nothing And ws.Cells(rowIndex, unsortedCol.column).Value = 1 Then
                imageFiles.Add imagePath
                ' Debugging message
                Debug.Print "Unsorted image added: " & imagePath
            End If
        ElseIf filterOption = "Show Only Sorted" Then
            isSorted = False
            For Each categoryCol In ws.Rows(1).Columns
                If categoryCol.Value <> "Unsorted" And ws.Cells(rowIndex, categoryCol.column).Value = 1 Then
                    isSorted = True
                    Exit For
                End If
            Next categoryCol
            If isSorted Then
                imageFiles.Add imagePath
                ' Debugging message
                Debug.Print "Sorted image added: " & imagePath
            End If
        End If
    Next rowIndex

    ' Display the first image if available
    If imageFiles.Count > 0 Then
        currentIndex = 1
        UpdateImageDisplay
    Else
        ' Clear the image display if no images match the filter
        currentIndex = 0
        If Not Me.ImageControl Is Nothing Then
            Me.ImageControl.Picture = Nothing
        End If
        lblCurrentImageName.caption = ""
    End If

    ' Update the counts
    UpdateImageCounts

    ' Debugging message
    Debug.Print "Total images loaded: " & imageFiles.Count
End Sub


Private Sub btnCloseAndQuit_Click()
    Unload Me
End Sub

Private Sub cmdCreateAllFolders_Click()
    createAllFolders
End Sub

Private Sub cmdRemoveEmptyFolders_Click()
    RemoveEmptyFolders
End Sub



Private Sub cmdChooseDirectory_Click()
    ' Use a function to get the selected directory path
    Dim selectedPath As String
    selectedPath = chooseDirectory()

    If selectedPath <> "" Then
        ' Update the directory path label on the form
        lblDirectoryPath.caption = selectedPath
        
        ' Store the selected path in the public variable
        rootPath = selectedPath
        
        ' Parse directories, load images into sheet, and initialize imageFiles collection
        ParseAndLoadImages selectedPath
        
        ' Update subdirectory names in the BerichtLabels sheet
        UpdateSubDirectoryNames
        
        ' Recreate user form buttons based on new data
        CreateUserFormButtons
        
        ' Optional: Display the first image if available
        If imageFiles.Count > 0 Then
            UpdateImageDisplay ' Assuming this subroutine handles image display logic
        End If
    Else
        ' Update label if no directory was selected
        lblDirectoryPath.caption = "No directory selected"
    End If
    
        ' Set the flag to indicate that images are loaded
    imagesLoadedFlag = True
    
        ' Call FilterAndReloadImages after loading images
    FilterAndReloadImages

    ' Assuming there's an invisible TextBox to manage focus
    UpdateImageCounts
    InvisibleTextBox.SetFocus
End Sub

' Code for the "Previous" button
Private Sub btnPrevious_Click()
    If currentIndex > 1 Then
        currentIndex = currentIndex - 1
        UpdateImageDisplay
        UpdateImageCounts
    End If
    InvisibleTextBox.SetFocus ' Set focus to the invisible TextBox
End Sub

' Code for the "Next" button
Private Sub btnNext_Click()
    If currentIndex < imageFiles.Count Then
        currentIndex = currentIndex + 1
        UpdateImageDisplay
        UpdateImageCounts
    End If
    InvisibleTextBox.SetFocus ' Set focus to the invisible TextBox
End Sub

Private Sub InvisibleTextBox_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)
    Select Case KeyCode
        Case vbKeyA ' ASCII value for "A"
            btnPrevious_Click ' Simulate clicking the "Previous" button
        Case vbKeyD ' ASCII value for "D"
            btnNext_Click ' Simulate clicking the "Next" button
    End Select
End Sub
Private Sub UpdateImageCounts()
    Dim totalImages As Long
    Dim unsortedImages As Long
    Dim ws As Worksheet
    Dim rowIndex As Long
    Dim lastRow As Long
    Dim unsortedCol As Range
    Dim currentImageIndex As Long
    Dim totalImageCount As Long

    Set ws = ThisWorkbook.Sheets("PSHelperSheet")
    totalImages = ws.Cells(ws.Rows.Count, 1).End(xlUp).row - 1 ' Assuming the first row is headers
    unsortedImages = 0
    
    ' Find the column for "Unsorted"
    Set unsortedCol = ws.Rows(1).Find(What:="Unsorted", LookIn:=xlValues, LookAt:=xlWhole)
    
    If Not unsortedCol Is Nothing Then
        ' Count the number of unsorted images
        lastRow = ws.Cells(ws.Rows.Count, 1).End(xlUp).row
        For rowIndex = 2 To lastRow ' Start from row 2 to skip headers
            If ws.Cells(rowIndex, unsortedCol.column).Value = 1 Then
                unsortedImages = unsortedImages + 1
            End If
        Next rowIndex
    End If
    
    currentImageIndex = currentIndex
    totalImageCount = imageFiles.Count
    
    lblImageCounts.caption = "Image " & currentImageIndex & " of " & totalImageCount & _
                             " - Total Images " & totalImages & _
                             " - Unsorted Images " & unsortedImages
End Sub

Public Sub ParseAndLoadImages(ByVal rootDirectoryPath As String)
    Dim ws As Worksheet
    Dim labelsSheet As Worksheet
    Dim fso As Object
    Dim directoriesQueue As Collection
    Dim currentPath As String
    Dim folder As Object
    Dim file As Object
    Dim subFolder As Object
    Dim imageFilesDict As Object
    Dim lastRow As Long
    Dim lastCol As Long
    Dim rowIndex As Long
    Dim fullPath As String
    Dim fileName As String
    Dim categoryName As String
    Dim catCol As Object
    Dim colIndex As Long

    Set fso = CreateObject("Scripting.FileSystemObject")
    Set directoriesQueue = New Collection
    Set ws = ThisWorkbook.Sheets("PSHelperSheet")
    Set labelsSheet = ThisWorkbook.Sheets("PSCategoryLabels")
    Set imageFilesDict = CreateObject("Scripting.Dictionary")
    Set catCol = CreateObject("Scripting.Dictionary")

    ' Initialize
    directoriesQueue.Add rootDirectoryPath
    If subDirectoryNames Is Nothing Then InitializeSubDirectoryNames
    If Not subDirectoryNames.Exists("Unsorted") Then subDirectoryNames.Add "Unsorted", "Unsorted"

    ' Clear existing sheet contents
    ws.Range("A1:ZZ" & ws.Rows.Count).ClearContents

    ' Load category labels from PSCategoryLabels
    LoadDynamicButtonCategories ws, catCol, "A"
    LoadDynamicButtonCategories ws, catCol, "B"
    LoadDynamicButtonCategories ws, catCol, "C"

    ' Loop through directories and files
    While directoriesQueue.Count > 0
        currentPath = directoriesQueue(1)
        directoriesQueue.Remove 1
        Set folder = fso.GetFolder(currentPath)

        For Each file In folder.Files
            If LCase(file.Type) Like "*jpeg*" Or LCase(file.Type) Like "*jpg*" Or LCase(file.Type) Like "*png*" Then
                fullPath = file.path
                fileName = Mid(fullPath, InStrRev(fullPath, "\") + 1)
                
                ' Determine the category based on the path
                If currentPath = rootDirectoryPath Then
                    categoryName = "Unsorted"
                Else
                    Dim categoryStart As Integer
                    categoryStart = InStrRev(fullPath, "\", InStrRev(fullPath, "\") - 1)
                    Dim categoryEnd As Integer
                    categoryEnd = InStrRev(fullPath, "\")
                    categoryName = Mid(fullPath, categoryStart + 1, categoryEnd - categoryStart - 1)
                End If

                ' Add category column if it does not exist
                If Not catCol.Exists(categoryName) Then
                    catCol.Add categoryName, catCol.Count + 2
                    ws.Cells(1, catCol(categoryName)).Value = categoryName
                End If

                ' Add file to the helper sheet
                If imageFilesDict.Exists(fileName) Then
                    rowIndex = imageFilesDict(fileName)
                    ws.Cells(rowIndex, catCol(categoryName)).Value = "1"
                Else
                    rowIndex = ws.Cells(ws.Rows.Count, "A").End(xlUp).row + 1
                    ws.Cells(rowIndex, 1).Value = fileName
                    ws.Cells(rowIndex, catCol(categoryName)).Value = "1"
                    imageFilesDict.Add fileName, rowIndex
                End If
            End If
        Next file

        ' Add subdirectories to the queue
        For Each subFolder In folder.SubFolders
            If Not subDirectoryNames.Exists(subFolder.Name) Then
                subDirectoryNames.Add subFolder.Name, subFolder.Name
            End If
            directoriesQueue.Add subFolder.path
        Next subFolder
    Wend

    ' Find the last row and last column
    lastRow = ws.Cells(ws.Rows.Count, 1).End(xlUp).row
    lastCol = ws.Cells(1, ws.Columns.Count).End(xlToLeft).column

    ' Sort the helper sheet by the filenames
    With ws.Sort
        .SortFields.Clear
        .SortFields.Add key:=ws.Columns(1), Order:=xlAscending
        .SetRange ws.Range(ws.Cells(1, 1), ws.Cells(lastRow, lastCol))
        .Header = xlYes
        .Apply
    End With

    ' Initialize the imageFiles collection in the correct order
    Set imageFiles = New Collection
    For rowIndex = 2 To lastRow ' Assuming the first row is headers
        fileName = ws.Cells(rowIndex, 1).Value
        Dim imagePath As String
        imagePath = ""

        ' Find the first category where the image exists
        For colIndex = 2 To lastCol
            If ws.Cells(rowIndex, colIndex).Value = 1 Then
                categoryName = ws.Cells(1, colIndex).Value
                If categoryName = "Unsorted" Then
                    imagePath = rootPath & "\" & fileName
                Else
                    imagePath = rootPath & "\" & categoryName & "\" & fileName
                End If
                If Dir(imagePath) <> "" Then
                    Exit For
                End If
            End If
        Next colIndex

        ' Default to root directory if no path was found
        If imagePath = "" Then
            imagePath = rootPath & "\" & fileName
        End If

        If Dir(imagePath) <> "" Then
            imageFiles.Add imagePath
        End If
    Next rowIndex
End Sub

Private Sub LoadDynamicButtonCategories(ws As Worksheet, ByRef catCol As Object, columnRange As String)
    Dim labelsSheet As Worksheet
    Set labelsSheet = ThisWorkbook.Sheets("PSCategoryLabels")
    
    Dim lastRow As Long
    Dim catName As String
    Dim i As Long
    lastRow = labelsSheet.Cells(labelsSheet.Rows.Count, columnRange).End(xlUp).row
    For i = 1 To lastRow
        catName = Trim(labelsSheet.Cells(i, columnRange).Value)
        If Not catCol.Exists(catName) Then
            catCol.Add catName, catCol.Count + 2
            ws.Cells(1, catCol(catName)).Value = catName
        End If
    Next i
End Sub

Private Sub UpdateImageDisplay()
    If currentIndex = 0 Then
        currentIndex = 1
    End If
    
    If imageFiles.Count >= currentIndex Then
        Dim imageName As String
        imageName = imageFiles.Item(currentIndex)
        
        ' Extract the image file name only (excluding path)
        imageName = Mid(imageName, InStrRev(imageName, "\") + 1)
        
        ' Find the row in PSHelperSheet corresponding to this imageName
        With ThisWorkbook.Sheets("PSHelperSheet")
            Dim found As Range
            Set found = .Columns(1).Find(What:=imageName, LookIn:=xlValues, LookAt:=xlWhole)
            If Not found Is Nothing Then
                currentImageRow = found.row
                
                ' Initialize imagePath
                Dim imagePath As String
                imagePath = ""
                
                ' Check the columns to find the first category where the image exists
                Dim colIndex As Integer
                For colIndex = 2 To .Cells(1, .Columns.Count).End(xlToLeft).column
                    If .Cells(currentImageRow, colIndex).Value = 1 Then
                        Dim category As String
                        category = .Cells(1, colIndex).Value
                        If category = "Unsorted" Then
                            imagePath = rootPath & "\" & imageName
                        Else
                            imagePath = rootPath & "\" & category & "\" & imageName
                        End If
                        ' Check if the file exists in this path
                        If Dir(imagePath) <> "" Then
                            Exit For
                        End If
                    End If
                Next colIndex
                
                ' If no path was found, default to root directory
                If imagePath = "" Then
                    imagePath = rootPath & "\" & imageName
                End If

                ' Display the image if it exists
                If Dir(imagePath) <> "" Then
                    With ImageControl
                        .Picture = LoadPicture(imagePath)
                        .PictureSizeMode = fmPictureSizeModeZoom  ' Maintain aspect ratio
                    End With
                Else
                    MsgBox "Image not found: " & imagePath
                End If
            Else
                currentImageRow = 0 ' Reset or handle error
                MsgBox "Image row not found in PSHelperSheet for: " & imageName
            End If
        End With
    End If
    updateButtonStates
End Sub

Private Sub CreateUserFormButtons()
    Dim ws As Worksheet
    Set ws = ThisWorkbook.Sheets("PSCategoryLabels")

    Const btnWidth As Integer = 80
    Const btnHeight As Integer = 20
    Const spaceBetween As Integer = 5
    Const offsetX As Integer = 5
    Const offsetY As Integer = 5
    Const maxRows As Integer = 5

    Set buttonCollection = New Collection
    Set existingButtonCaptions = New Scripting.Dictionary

    CreateButtonBlock ws, "A", Me.ButtonsBericht, offsetX, offsetY, btnWidth, btnHeight, spaceBetween, maxRows
    CreateButtonBlock ws, "B", Me.ButtonsVGSeminar, offsetX, offsetY, btnWidth, btnHeight, spaceBetween, maxRows
    CreateButtonBlock ws, "C", Me.ButtonsSubfolders, offsetX, offsetY, btnWidth, btnHeight, spaceBetween, maxRows
End Sub

Private Sub CreateButtonBlock(ws As Worksheet, column As String, targetFrame As MSForms.Frame, _
                              offsetX As Integer, offsetY As Integer, btnWidth As Integer, _
                              btnHeight As Integer, spaceBetween As Integer, maxRows As Integer)
    Dim lastRow As Long
    lastRow = ws.Cells(ws.Rows.Count, column).End(xlUp).row

    Dim i As Integer
    Dim posIndex As Integer
    Dim topPos As Integer
    topPos = offsetY ' Initialize top position for buttons
    
     For i = 1 To lastRow
        Dim caption As String
        caption = ws.Cells(i, column).Value

        If Not existingButtonCaptions.Exists(caption) Then
            Dim dynamicButton As CButton
            Set dynamicButton = New CButton
            posIndex = i - 1

            ' Calculate top position dynamically based on the number of rows
            topPos = offsetY + (posIndex \ maxRows) * (btnHeight + spaceBetween)

            ' Create a new button and set properties
            With targetFrame.Controls.Add("Forms.CommandButton.1", "Button" & column & i, True)
                .caption = caption
                .Width = btnWidth
                .Height = btnHeight
                .Left = offsetX + (posIndex Mod maxRows) * (btnWidth + spaceBetween)
                .Top = topPos
            End With

            dynamicButton.categoryName = caption
            Set dynamicButton.btn = targetFrame.Controls("Button" & column & i)
            Set dynamicButton.ParentForm = Me
            buttonCollection.Add dynamicButton
            existingButtonCaptions.Add caption, True
        End If
    Next i

    ' Adjust ScrollHeight for the frame based on the position of the last button
    If lastRow > 0 Then
        targetFrame.ScrollBars = fmScrollBarsVertical
        targetFrame.ScrollHeight = topPos + btnHeight + spaceBetween
    End If
End Sub

Public Sub ToggleCategoryAssignment(ByVal category As String, ByVal ButtonCaption As String)
    Dim ws As Worksheet
    Set ws = ThisWorkbook.Sheets("PSHelperSheet")

    ' Step 1: Get the current image name
    Dim currentImageName As String
    currentImageName = GetCurrentImageName()
    
    If currentImageName = "" Then
        MsgBox "Current image name is empty."
        Exit Sub
    End If
    
    ' Step 2: Find the row for the current image
    Dim foundRow As Range
    Set foundRow = ws.Columns(1).Find(What:=currentImageName, LookIn:=xlValues, LookAt:=xlWhole)
    
    If foundRow Is Nothing Then
        MsgBox "Image row not found in PSHelperSheet."
        Exit Sub
    End If

    ' Step 3: Find the column for the category
    Dim categoryColumn As Range
    Set categoryColumn = ws.Rows(1).Find(What:=category, LookIn:=xlValues, LookAt:=xlWhole)
    
    If categoryColumn Is Nothing Then
        MsgBox "Category column not found in PSHelperSheet for '" & category & "'."
        Exit Sub
    End If
    
    ' Step 4: Toggle the selected category
    With ws.Cells(foundRow.row, categoryColumn.column)
        If .Value = 1 Then
            .Value = ""
        Else
            .Value = 1
            ' If assigning a new category, unassign "Unsorted"
            Dim unsortedColumn As Range
            Set unsortedColumn = ws.Rows(1).Find(What:="Unsorted", LookIn:=xlValues, LookAt:=xlWhole)
            If Not unsortedColumn Is Nothing Then
                ws.Cells(foundRow.row, unsortedColumn.column).Value = ""
            End If
        End If
    End With

    ' Step 5: If "Unsorted" is clicked, unassign all other categories
    If category = "Unsorted" Then
        Dim colIndex As Long
        For colIndex = 2 To ws.Cells(1, ws.Columns.Count).End(xlToLeft).column
            If ws.Cells(1, colIndex).Value <> "Unsorted" Then
                ws.Cells(foundRow.row, colIndex).Value = ""
            End If
        Next colIndex
        ' Ensure "Unsorted" is assigned
        ws.Cells(foundRow.row, categoryColumn.column).Value = 1
    End If

    ' Step 6: Check if no categories are assigned, then move to Unsorted (root directory)
    Dim noCategories As Boolean
    noCategories = True
    For colIndex = 2 To ws.Cells(1, ws.Columns.Count).End(xlToLeft).column
        If ws.Cells(foundRow.row, colIndex).Value = 1 Then
            noCategories = False
            Exit For
        End If
    Next colIndex

    If noCategories Then
        Set categoryColumn = ws.Rows(1).Find(What:="Unsorted", LookIn:=xlValues, LookAt:=xlWhole)
        If Not categoryColumn Is Nothing Then
            ws.Cells(foundRow.row, categoryColumn.column).Value = 1
        End If
    End If

    ' Ensure the file system matches the PSHelperSheet state
    EnsureFileSystemMatchesSheet currentImageName

    updateButtonStates
    UpdateImageCounts
End Sub

Private Sub EnsureFileSystemMatchesSheet(imageName As String)
    Dim fso As Object
    Set fso = CreateObject("Scripting.FileSystemObject")
    
    Dim ws As Worksheet
    Set ws = ThisWorkbook.Sheets("PSHelperSheet")

    Dim foundRow As Range
    Set foundRow = ws.Columns(1).Find(What:=imageName, LookIn:=xlValues, LookAt:=xlWhole)
    If foundRow Is Nothing Then
        MsgBox "Image not found in PSHelperSheet"
        Exit Sub
    End If

    Dim colIndex As Long
    Dim sourcePath As String
    Dim destinationPath As String
    Dim imageInUnsorted As Boolean
    imageInUnsorted = False

    ' First, ensure the image is in all categories marked with a 1
    For colIndex = 2 To ws.Cells(1, ws.Columns.Count).End(xlToLeft).column
        Dim category As String
        category = ws.Cells(1, colIndex).Value
        If ws.Cells(foundRow.row, colIndex).Value = 1 Then
            If category = "Unsorted" Then
                destinationPath = rootPath & "\" & imageName
                imageInUnsorted = True
            Else
                destinationPath = rootPath & "\" & category & "\" & imageName
                If Not fso.FolderExists(rootPath & "\" & category) Then
                    fso.CreateFolder rootPath & "\" & category
                End If
            End If
            If Not fso.FileExists(destinationPath) Then
                sourcePath = rootPath & "\" & imageName
                If fso.FileExists(sourcePath) Then
                    fso.CopyFile sourcePath, destinationPath
                Else
                    ' Check in other category folders
                    Dim subFolder As Object
                    For Each subFolder In fso.GetFolder(rootPath).SubFolders
                        sourcePath = subFolder.path & "\" & imageName
                        If fso.FileExists(sourcePath) Then
                            fso.CopyFile sourcePath, destinationPath
                            Exit For
                        End If
                    Next subFolder
                End If
            End If
        End If
    Next colIndex

    ' If image is not marked as "Unsorted", remove it from the root directory
    If Not imageInUnsorted Then
        sourcePath = rootPath & "\" & imageName
        If fso.FileExists(sourcePath) Then
            fso.DeleteFile sourcePath
        End If
    End If
    
    ' Remove the image from any categories not marked with a 1
    Dim folder As Object
    For Each folder In fso.GetFolder(rootPath).SubFolders
        Dim folderCategory As Range
        Set folderCategory = ws.Rows(1).Find(What:=folder.Name, LookIn:=xlValues, LookAt:=xlWhole)
        If Not folderCategory Is Nothing Then
            If ws.Cells(foundRow.row, folderCategory.column).Value <> 1 Then
                Dim fileToDelete As String
                fileToDelete = folder.path & "\" & imageName
                If fso.FileExists(fileToDelete) Then
                    fso.DeleteFile fileToDelete
                End If
                ' Remove the folder if it is empty
                If fso.GetFolder(folder.path).Files.Count = 0 Then
                    fso.DeleteFolder folder.path
                End If
            End If
        End If
    Next folder
End Sub

Public Sub updateButtonStates()
    Dim ws As Worksheet
    Set ws = ThisWorkbook.Sheets("PSHelperSheet")
    Dim currentImageName As String
    currentImageName = GetCurrentImageName()

    If currentImageName = "" Then Exit Sub
    
    Dim foundRow As Range
    Set foundRow = ws.Columns(1).Find(currentImageName, LookIn:=xlValues, LookAt:=xlWhole)

    If Not foundRow Is Nothing Then
        Dim btn As Object
        For Each btn In buttonCollection
            Dim btnObj As CButton
            Set btnObj = btn
            Dim categoryCol As Range
            Set categoryCol = ws.Rows(1).Find(btnObj.categoryName, LookIn:=xlValues, LookAt:=xlWhole)
            If Not categoryCol Is Nothing Then
                If ws.Cells(foundRow.row, categoryCol.column).Value = 1 Then
                    btnObj.btn.ForeColor = vbRed
                Else
                    btnObj.btn.ForeColor = vbBlack
                End If
            End If
        Next btn
    End If
End Sub

Public Function GetCurrentImageName() As String
    If imageFiles.Count >= currentIndex Then
        Dim imagePath As String
        imagePath = imageFiles.Item(currentIndex)
        GetCurrentImageName = Mid(imagePath, InStrRev(imagePath, "\") + 1)
    Else
        GetCurrentImageName = ""
    End If
    lblCurrentImageName.caption = GetCurrentImageName
End Function


Private Sub btnClearSheets_Click()
    Dim helperSheet As Worksheet
    Dim berichtLabelsSheet As Worksheet
    
    Set helperSheet = ThisWorkbook.Sheets("PSHelperSheet")
    Set berichtLabelsSheet = ThisWorkbook.Sheets("PSCategoryLabels")
    
    helperSheet.Cells.ClearContents
    berichtLabelsSheet.Columns("D").ClearContents
        
    ' Clear the ImageControl
    If Not Me.ImageControl Is Nothing Then
        Me.ImageControl.Picture = Nothing
    End If
    
    ' Clear imagePath (assuming imagePath is a String variable)
    imagePath = ""
    
    ' Reinitialize imageFiles Collection
    Set imageFiles = New Collection
    
    ' Reset directory path label
    lblDirectoryPath.caption = "No directory chosen"
    lblCurrentImageName = ""
    
End Sub


Private Sub btnShowCounts_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
    ShowCategoryCounts
End Sub

Private Sub btnShowCounts_MouseUp(ByVal Button As Integer, ByVal Shift As Integer, ByVal x As Single, ByVal y As Single)
    RestoreCategoryCaptions
    InvisibleTextBox.SetFocus
End Sub

Private Sub ShowCategoryCounts()
    Dim ws As Worksheet
    Set ws = ThisWorkbook.Sheets("PSHelperSheet")
    
    Dim categoryCounts As Scripting.Dictionary
    Set categoryCounts = GetCategoryCounts(ws)
    
    Dim btn As Object
    For Each btn In buttonCollection
        Dim btnObj As CButton
        Set btnObj = btn
        Dim categoryCount As Long
        categoryCount = categoryCounts(btnObj.categoryName)
        btnObj.btn.caption = "(" & categoryCount & ") " & btnObj.categoryName
        ' Make the button caption bold if count is non-zero
        If categoryCount > 0 Then
            btnObj.btn.Font.Bold = True
        Else
            btnObj.btn.Font.Bold = False
        End If
    Next btn
End Sub

Private Sub RestoreCategoryCaptions()
    Dim btn As Object
    For Each btn In buttonCollection
        Dim btnObj As CButton
        Set btnObj = btn
        btnObj.btn.caption = btnObj.categoryName
        btnObj.btn.Font.Bold = False ' Reset the font to normal
    Next btn
End Sub

Private Function GetCategoryCounts(ws As Worksheet) As Scripting.Dictionary
    Dim categoryCounts As Scripting.Dictionary
    Set categoryCounts = New Scripting.Dictionary
    
    Dim lastRow As Long
    Dim lastCol As Long
    Dim rowIndex As Long
    Dim colIndex As Long
    Dim categoryName As String
    
    lastRow = ws.Cells(ws.Rows.Count, 1).End(xlUp).row
    lastCol = ws.Cells(1, ws.Columns.Count).End(xlToLeft).column
    
    ' Initialize category counts
    For colIndex = 2 To lastCol
        categoryName = ws.Cells(1, colIndex).Value
        If Not categoryCounts.Exists(categoryName) Then
            categoryCounts.Add categoryName, 0
        End If
    Next colIndex
    
    ' Count the images in each category
    For rowIndex = 2 To lastRow ' Assuming the first row is headers
        For colIndex = 2 To lastCol
            If ws.Cells(rowIndex, colIndex).Value = 1 Then
                categoryName = ws.Cells(1, colIndex).Value
                categoryCounts(categoryName) = categoryCounts(categoryName) + 1
            End If
        Next colIndex
    Next rowIndex
    
    Set GetCategoryCounts = categoryCounts
End Function

--------------------------------------------------

### SHEET/WORKBOOK CODE: Sheet3
==================================================
--------------------------------------------------

### SHEET/WORKBOOK CODE: Sheet2
==================================================
--------------------------------------------------

### CLASS MODULE CODE: CButton
==================================================
Public WithEvents btn As MSForms.CommandButton
Public ParentForm As UserForm
Public categoryName As String

Private Sub btn_Click()
    PhotoSorterForm.ToggleCategoryAssignment categoryName, btn.caption
    ParentForm.Controls("InvisibleTextBox").SetFocus
End Sub

--------------------------------------------------

### SHEET/WORKBOOK CODE: Sheet5
==================================================
--------------------------------------------------

### SHEET/WORKBOOK CODE: Sheet4
==================================================
--------------------------------------------------

### MODULE CODE: PhotoSorter
==================================================
Option Explicit
' Global dictionary to hold subdirectory names
Public subDirectoryNames As Scripting.Dictionary
Public rootPath As String

' Display the Photo Sorter form
Sub btnPhotoSorter_Click()
    PhotoSorterForm.Show vbModeless
End Sub

' Initialize the global dictionary
Public Sub InitializeSubDirectoryNames()
    Set subDirectoryNames = New Scripting.Dictionary
End Sub

' Function to choose a directory using FileDialog
Function chooseDirectory() As String
    Dim fd As fileDialog
    Set fd = Application.fileDialog(msoFileDialogFolderPicker)
    
    With fd
        If .Show = -1 Then ' if OK is pressed
            chooseDirectory = .SelectedItems(1)
        Else
            chooseDirectory = ""
        End If
    End With
    
    Set fd = Nothing
End Function

' Update a worksheet with subdirectory names from the global dictionary
Sub UpdateSubDirectoryNames()
    Dim ws As Worksheet
    Set ws = ThisWorkbook.Sheets("PSCategoryLabels")
    ws.Columns(4).ClearContents
    
    Dim counter As Long
    counter = 1
    
    Dim key As Variant
    For Each key In subDirectoryNames.Keys
        ws.Cells(counter, 4).Value = key
        counter = counter + 1
    Next key
End Sub

' Load category labels into a dictionary from the specified columns
Sub LoadDynamicButtonCategories(ws As Worksheet, ByRef catCol As Object, columnRange As String)
    Dim labelsSheet As Worksheet
    Set labelsSheet = ThisWorkbook.Sheets("PSCategoryLabels")
    
    Dim lastRow As Long
    Dim catName As String
    Dim i As Long
    lastRow = labelsSheet.Cells(labelsSheet.Rows.Count, columnRange).End(xlUp).row
    For i = 1 To lastRow
        catName = Trim(labelsSheet.Cells(i, columnRange).Value)
        If Not catCol.Exists(catName) Then
            catCol.Add catName, catCol.Count + 2
            ws.Cells(1, catCol(catName)).Value = catName
        End If
    Next i
End Sub

' Create folders for every category listed
Public Sub createAllFolders()
    Dim fso As Object
    Dim ws As Worksheet
    Dim lastRow As Long, i As Long
    Dim cat As String, folderPath As String
    Dim col As Variant
    
    Set fso = CreateObject("Scripting.FileSystemObject")
    folderPath = rootPath   ' assumes rootPath is already set
    
    Set ws = ThisWorkbook.Sheets("PSCategoryLabels")
    ' categories in columns A, B, C
    For Each col In Array("A", "B", "C")
        lastRow = ws.Cells(ws.Rows.Count, col).End(xlUp).row
        For i = 1 To lastRow
            cat = Trim(ws.Cells(i, col).Value)
            If cat <> "" Then
                If Not fso.FolderExists(folderPath & "\" & cat) Then
                    fso.CreateFolder folderPath & "\" & cat
                End If
            End If
        Next i
    Next col
    
    MsgBox "Alle Kategorien-Ordner erstellt.", vbInformation
End Sub

' Remove any empty subfolders under rootPath
Public Sub RemoveEmptyFolders()
    Dim fso As Object
    Dim rootFld As Object, subFld As Object
    Dim i As Integer
    
    Set fso = CreateObject("Scripting.FileSystemObject")
    Set rootFld = fso.GetFolder(rootPath)
    
    ' iterate backwards so removal doesn't skip siblings
    For i = rootFld.SubFolders.Count To 1 Step -1
        Set subFld = rootFld.SubFolders(i)
        If subFld.Files.Count = 0 And subFld.SubFolders.Count = 0 Then
            fso.DeleteFolder subFld.path
        End If
    Next i
    
    MsgBox "Leere Ordner entfernt.", vbInformation
End Sub

--------------------------------------------------

### MODULE CODE: ExportAllVBA
==================================================
Sub ExportAllVBA()
    Dim VBComp As Object
    Dim VBProj As Object
    Dim CodeMod As Object
    Dim FileNum As Integer
    Dim i As Long
    Dim ExportPath As String
    Dim CurrentDate As String
    Dim folderPath As String
    Dim fd As fileDialog
    Dim FolderSelected As Boolean
    
    On Error GoTo ErrorHandler
    
    ' Get the current date in yyyy-mm-dd format
    CurrentDate = Format(Date, "yyyy-mm-dd")
    
    ' Set reference to the VBA project
    Set VBProj = ThisWorkbook.VBProject
    
    ' Prompt user to select a folder
    Set fd = Application.fileDialog(msoFileDialogFolderPicker)
    fd.Title = "Select Folder to Save Exported VBA Code"
    FolderSelected = fd.Show
    
    If FolderSelected = -1 Then
        folderPath = fd.SelectedItems(1)
    Else
        MsgBox "Export cancelled. No folder selected.", vbExclamation
        Exit Sub
    End If
    
    ' Define the export path with the current date prepended
    ExportPath = folderPath & "\" & CurrentDate & "_ExportedVBA.txt"
    
    ' Create or open the output file
    FileNum = FreeFile
    Open ExportPath For Output As #FileNum
    
    ' Loop through each component in the project
    For Each VBComp In VBProj.VBComponents
        ' Skip the current macro module
        If VBComp.Name = "ModuleName" Then ' Replace "ModuleName" with the name of the module containing this code
            Set CodeMod = VBComp.CodeModule
            For i = 1 To CodeMod.CountOfLines
                ' Skip the current procedure
                If Not InStr(1, CodeMod.Lines(i, 1), "Sub ExportAllVBA", vbTextCompare) > 0 Then
                    Exit For
                End If
            Next i
        End If

        ' Check the type of component and write the appropriate header
        Select Case VBComp.Type
            Case 1 ' Standard module
                Print #FileNum, "### MODULE CODE: " & VBComp.Name
            Case 2 ' Class module
                Print #FileNum, "### CLASS MODULE CODE: " & VBComp.Name
            Case 3 ' User form
                Print #FileNum, "### FORM CODE: " & VBComp.Name
            Case Else ' Sheet or ThisWorkbook
                Print #FileNum, "### SHEET/WORKBOOK CODE: " & VBComp.Name
        End Select
        Print #FileNum, String(50, "=")
        
        ' Set reference to the code module
        Set CodeMod = VBComp.CodeModule
        
        ' Loop through each line of code in the module
        For i = 1 To CodeMod.CountOfLines
            ' Exclude the current macro
            If Not (VBComp.Name = "ModuleName" And InStr(1, CodeMod.Lines(i, 1), "Sub ExportAllVBA", vbTextCompare) > 0) Then ' Replace "ModuleName" with the name of the module containing this code
                Print #FileNum, CodeMod.Lines(i, 1)
            End If
        Next i
        
        ' Add a separator for readability
        Print #FileNum, String(50, "-")
        Print #FileNum, ""
    Next VBComp
    
    ' Close the output file
    Close #FileNum
    
    ' Notify the user
    MsgBox "Export complete. The code has been saved to '" & ExportPath & "'.", vbInformation
    Exit Sub
    
ErrorHandler:
    If FileNum <> 0 Then Close #FileNum
    MsgBox "Error " & Err.Number & ": " & Err.description, vbCritical
End Sub

--------------------------------------------------

### SHEET/WORKBOOK CODE: Sheet6
==================================================
--------------------------------------------------

### MODULE CODE: ImportSelbstbeurteilungKunde
==================================================
Sub btnSelbsbeurteilung_Click()
    Dim filePath As String
    Dim sourceWb As Workbook
    Dim targetWb As Workbook
    Dim sourceWs As Worksheet
    Dim targetWs As Worksheet
    Dim i As Long
    Dim itemCode As String

    ' Let user pick the source file
    With Application.fileDialog(msoFileDialogFilePicker)
        .Title = "Wähle die Selbstbeurteilung-Datei"
        .Filters.Clear
        .Filters.Add "Excel Dateien", "*.xlsx; *.xlsm"
        If .Show <> -1 Then Exit Sub
        filePath = .SelectedItems(1)
    End With

    ' Disable screen updating and alerts
    Application.ScreenUpdating = False
    Application.DisplayAlerts = False

    Set targetWb = ThisWorkbook
    Set targetWs = targetWb.Sheets("SelbstbeurteilungKunde")

    Set sourceWb = Workbooks.Open(fileName:=filePath, ReadOnly:=True)
    On Error GoTo CleanFail

    Set sourceWs = sourceWb.Sheets("Selbstbeurteilung Kunde")

    ' Copy columns D,E,F rows 3 to 706 if column A is not blank
    For i = 3 To 706
        itemCode = Trim(CStr(sourceWs.Cells(i, 1).Value)) ' Column A

        If itemCode <> "" Then
            targetWs.Cells(i, 4).Value = sourceWs.Cells(i, 4).Value  ' Column D
            targetWs.Cells(i, 5).Value = sourceWs.Cells(i, 5).Value  ' Column E
            targetWs.Cells(i, 6).Value = sourceWs.Cells(i, 6).Value  ' Column F
        End If
    Next i

    sourceWb.Close SaveChanges:=False
    Application.ScreenUpdating = True
    Application.DisplayAlerts = True

    MsgBox "Import abgeschlossen.", vbInformation
    Exit Sub

CleanFail:
    MsgBox "Fehler beim Import: " & Err.description, vbCritical
    On Error Resume Next
    sourceWb.Close SaveChanges:=False
    Application.ScreenUpdating = True
    Application.DisplayAlerts = True
End Sub




--------------------------------------------------

### MODULE CODE: AutoBericht
==================================================

Option Explicit
' References needed:
'    – Microsoft Word xx.0 Object Library
'    – Microsoft Scripting Runtime

Sub ShowBerichtForm()
    BerichtForm.Show
End Sub





'===================================================================
' Opens Word application and loads both Master and Report documents
'===================================================================
Public Function OpenWordDocuments( _
    ByVal masterDocumentPath As String, _
    ByVal reportDocumentPath As String, _
    ByRef wordApp As Word.Application, _
    ByRef masterDocument As Word.Document, _
    ByRef reportDocument As Word.Document _
) As Boolean

    On Error Resume Next
    Set wordApp = CreateObject("Word.Application")
    On Error GoTo 0
    If wordApp Is Nothing Then
        MsgBox "Word application could not be started.", vbCritical
        Exit Function
    End If
    wordApp.Visible = True
    
    On Error Resume Next
    Set masterDocument = wordApp.Documents.Open(fileName:=masterDocumentPath, ReadOnly:=True, AddToRecentFiles:=False)
    If masterDocument Is Nothing Then
        MsgBox "Master document could not be opened:" & vbCrLf & masterDocumentPath, vbCritical
        wordApp.Quit
        Exit Function
    End If
    
    Set reportDocument = wordApp.Documents.Open(fileName:=reportDocumentPath, AddToRecentFiles:=False)
    If reportDocument Is Nothing Then
        MsgBox "Report document could not be opened:" & vbCrLf & reportDocumentPath, vbCritical
        masterDocument.Close SaveChanges:=False
        wordApp.Quit
        Exit Function
    End If
    On Error GoTo 0

    OpenWordDocuments = True
End Function

'===================================================================
' Determines hierarchy level: 1 for "1.", 2 for "1.1", 3 for "1.1.1"
'===================================================================
Public Function GetHierarchyLevel(ByVal codeString As String) As Long
    Dim dotCount As Long
    Dim i As Long
    
    For i = 1 To Len(codeString)
        If Mid(codeString, i, 1) = "." Then dotCount = dotCount + 1
    Next i
    
    GetHierarchyLevel = dotCount
End Function

'===================================================================
' Checks if a code belongs to the specified chapter
'===================================================================
Public Function IsChapterCode(ByVal codeString As String, ByVal chapterNumber As Long) As Boolean
    Dim chapterPrefix As String
    chapterPrefix = CStr(chapterNumber) & "."
    
    ' Check if code starts with the chapter prefix (e.g., "1.")
    IsChapterCode = (Left(codeString, Len(chapterPrefix)) = chapterPrefix)
End Function

'===================================================================
' Creates and populates the table for a specific chapter
'===================================================================
Public Sub CreateAndPopulateChapterTable(ByVal contentControl As Word.contentControl, ByVal evaluationWorksheet As Worksheet, ByVal masterCodeMap As Scripting.Dictionary, ByVal masterTable As Word.Table, ByVal chapterNumber As Long)
    Dim outputTable As Word.Table
    Dim lastRow As Long
    Dim currentRow As Long
    Dim rowIndex As Long
    Dim currentCode As String
    Dim hierarchyLevel As Long
    Dim assessmentLevel As Long
    Dim masterRowIndex As Long
    Dim description As String
    Dim recommendation As String
    Dim level2RowIndices As Collection
    Dim dataRowCount As Long
    
    ' Count data rows for this chapter only - SCAN ENTIRE WORKSHEET
    lastRow = evaluationWorksheet.Cells(evaluationWorksheet.Rows.Count, "A").End(xlUp).row
    dataRowCount = 0
    For currentRow = 1 To lastRow  ' SCAN FROM ROW 1 TO END
        currentCode = Trim(CStr(evaluationWorksheet.Cells(currentRow, "A").Value))
        If Len(currentCode) > 0 And IsChapterCode(currentCode, chapterNumber) Then
            hierarchyLevel = GetHierarchyLevel(currentCode)
            If hierarchyLevel >= 2 Then
                dataRowCount = dataRowCount + 1
                Debug.Print "Found code: " & currentCode & " (Level " & hierarchyLevel & ") at row " & currentRow
            End If
        End If
    Next currentRow
    
    If dataRowCount = 0 Then
        MsgBox "No Chapter " & chapterNumber & " data rows found to process.", vbCritical
        Exit Sub
    End If
    
    ' Clear and create table
    contentControl.Range.Delete
    Set outputTable = contentControl.Range.Document.Tables.Add(contentControl.Range, dataRowCount + 3, 3)
    Set level2RowIndices = New Collection
    
    ' Disable screen updating for speed
    Application.ScreenUpdating = False
    
    ' SET COLUMN WIDTHS FIRST (before any merging)
    With outputTable
        .PreferredWidthType = wdPreferredWidthPercent
        .PreferredWidth = 100
        .Columns(1).PreferredWidthType = wdPreferredWidthPercent
        .Columns(1).PreferredWidth = 20
        .Columns(2).PreferredWidthType = wdPreferredWidthPercent
        .Columns(2).PreferredWidth = 70
        .Columns(3).PreferredWidthType = wdPreferredWidthPercent
        .Columns(3).PreferredWidth = 10
    End With
    
    ' Populate header rows
    With outputTable
        .Cell(1, 1).Range.Text = ""  ' Introductory text (left blank)
        .Cell(1, 2).Range.Text = ""
        .Cell(1, 3).Range.Text = ""
        
        .Cell(2, 1).Range.Text = "Systempunkte mit Verbesserungspotential"
        .Cell(2, 2).Range.Text = ""
        .Cell(2, 3).Range.Text = ""
        
        .Cell(3, 1).Range.Text = "Ist-Zustand"
        .Cell(3, 2).Range.Text = "Lösungsansätze"
        .Cell(3, 3).Range.Text = "Prio"
    End With
    
    ' Populate data rows for this chapter only - SCAN ENTIRE WORKSHEET
    rowIndex = 4
    For currentRow = 1 To lastRow  ' SCAN FROM ROW 1 TO END
        currentCode = Trim(CStr(evaluationWorksheet.Cells(currentRow, "A").Value))
        If Len(currentCode) > 0 And IsChapterCode(currentCode, chapterNumber) Then
            hierarchyLevel = GetHierarchyLevel(currentCode)
            If hierarchyLevel >= 2 Then
                assessmentLevel = CLng(evaluationWorksheet.Cells(currentRow, "V").Value)
                description = ""
                recommendation = ""
                
                ' Get data from master table
                If masterCodeMap.Exists(currentCode) Then
                    masterRowIndex = masterCodeMap(currentCode)
                    description = Trim(Replace(masterTable.Cell(masterRowIndex, 2).Range.Text, vbCr & Chr(7), ""))
                    Debug.Print "Found in master: " & currentCode & " -> " & Left(description, 50)
                    
                    ' Get recommendation based on assessment level
                    Dim currentLevel As Long
                    For currentLevel = assessmentLevel To 1 Step -1
                        Dim levelColumnIndex As Long
                        levelColumnIndex = currentLevel + 2
                        If levelColumnIndex <= masterTable.Columns.Count Then
                            recommendation = Trim(Replace(masterTable.Cell(masterRowIndex, levelColumnIndex).Range.Text, vbCr & Chr(7), ""))
                            If Len(recommendation) > 0 Then Exit For
                        End If
                    Next currentLevel
                Else
                    Debug.Print "NOT found in master: " & currentCode
                End If
                
                ' Fill the table row
                If hierarchyLevel = 2 Then
                    ' Level 2: Section header (e.g., "1.1", "2.1")
                    outputTable.Cell(rowIndex, 1).Range.Text = currentCode & " " & description
                    outputTable.Cell(rowIndex, 2).Range.Text = ""
                    outputTable.Cell(rowIndex, 3).Range.Text = ""
                    level2RowIndices.Add rowIndex
                    Debug.Print "Added Level 2 row: " & currentCode & " at table row " & rowIndex
                Else
                    ' Level 3+: Detail row (e.g., "1.1.1", "2.1.1")
                    outputTable.Cell(rowIndex, 1).Range.Text = currentCode & " " & description
                    outputTable.Cell(rowIndex, 2).Range.Text = "• " & recommendation
                    outputTable.Cell(rowIndex, 3).Range.Text = ""
                    Debug.Print "Added Level 3+ row: " & currentCode & " at table row " & rowIndex
                End If
                
                rowIndex = rowIndex + 1
            End If
        End If
    Next currentRow
    
    ' Apply other formatting and fix column widths
    With outputTable
        .Borders.Enable = False
        .AutoFitBehavior wdAutoFitFixed
        
        ' Set table to use 100% of available width
        .PreferredWidthType = wdPreferredWidthPercent
        .PreferredWidth = 100
        
        ' Set individual column widths as percentages
        With .Columns(1)
            .PreferredWidthType = wdPreferredWidthPercent
            .PreferredWidth = 20
        End With
        
        With .Columns(2)
            .PreferredWidthType = wdPreferredWidthPercent
            .PreferredWidth = 70
        End With
        
        With .Columns(3)
            .PreferredWidthType = wdPreferredWidthPercent
            .PreferredWidth = 10
        End With
    End With
    
' Apply merging AFTER column widths are set
    On Error Resume Next
    ' Header rows: merge ONLY columns 1 and 2 (leave Prio column separate)
    outputTable.Cell(1, 1).Merge MergeTo:=outputTable.Cell(1, 2)  ' Header row 1: merge only cols 1+2
    outputTable.Cell(2, 1).Merge MergeTo:=outputTable.Cell(2, 2)  ' Header row 2: merge only cols 1+2
    
    ' Merge Level 2 section headers (first two columns only)
    Dim i As Long
    For i = 1 To level2RowIndices.Count
        Debug.Print "Merging Level 2 row: " & level2RowIndices(i)
        outputTable.Cell(level2RowIndices(i), 1).Merge MergeTo:=outputTable.Cell(level2RowIndices(i), 2)
    Next i
    On Error GoTo 0
    

    
    Application.ScreenUpdating = True
End Sub

'===================================================================
' Processes a single chapter - ready for multi-chapter expansion
'===================================================================
Public Sub ProcessSingleChapter(ByVal chapterNumber As Long, ByVal masterDocument As Word.Document, ByVal reportDocument As Word.Document, ByVal masterCodeMap As Scripting.Dictionary, ByVal evaluationWorksheet As Worksheet)
    Dim masterTable As Word.Table
    Dim targetContentControl As Word.contentControl
    Dim contentControlTag As String
    
    ' Find master table for this chapter
    contentControlTag = "Chapter" & CStr(chapterNumber)
    Set masterTable = Nothing
    Dim currentTable As Word.Table
    For Each currentTable In masterDocument.Tables
        If currentTable.Title = contentControlTag Then
            Set masterTable = currentTable
            Exit For
        End If
    Next
    If masterTable Is Nothing Then
        MsgBox "Master table '" & contentControlTag & "' not found.", vbCritical
        Exit Sub
    End If

    ' Find content control for this chapter
    Set targetContentControl = Nothing
    Dim currentContentControl As Word.contentControl
    For Each currentContentControl In reportDocument.ContentControls
        If currentContentControl.Tag = contentControlTag Then
            Set targetContentControl = currentContentControl
            Exit For
        End If
    Next
    If targetContentControl Is Nothing Then
        MsgBox "ContentControl '" & contentControlTag & "' not found.", vbCritical
        Exit Sub
    End If

    ' Process this chapter
    CreateAndPopulateChapterTable targetContentControl, evaluationWorksheet, masterCodeMap, masterTable, chapterNumber
    
    MsgBox "Chapter " & chapterNumber & " processed successfully!", vbInformation
End Sub

'===================================================================
' Main procedure - currently processes Chapter 1 only
'===================================================================
Public Sub ImportChapter1()
    Dim fileDialog As fileDialog
    Dim masterDocumentPath As String
    Dim reportDocumentPath As String
    Dim originalReportPath As String
    Dim wordApp As Word.Application
    Dim masterDocument As Word.Document
    Dim reportDocument As Word.Document
    Dim masterCodeMap As Scripting.Dictionary
    Dim evaluationWorksheet As Worksheet
    Dim saveDirectory As String
    Dim saveFileName As String
    Dim masterRowIndex As Long
    Dim currentCode As String

    ' File selection
    Set fileDialog = Application.fileDialog(msoFileDialogFilePicker)
    With fileDialog
        .Title = "Select Master Document"
        .Filters.Clear: .Filters.Add "Word Files", "*.doc; *.docx; *.docm"
        If .Show <> -1 Then Exit Sub
        masterDocumentPath = .SelectedItems(1)

        .Title = "Select Target Report Document"
        .Filters.Clear: .Filters.Add "Word Files", "*.doc; *.docx; *.docm"
        If .Show <> -1 Then Exit Sub
        reportDocumentPath = .SelectedItems(1)
    End With
    originalReportPath = reportDocumentPath

    ' Open documents
    If Not OpenWordDocuments(masterDocumentPath, reportDocumentPath, wordApp, masterDocument, reportDocument) Then Exit Sub

    ' Build master code lookup (for all chapters)
    Set masterCodeMap = New Scripting.Dictionary
    Dim currentTable As Word.Table
    For Each currentTable In masterDocument.Tables
        If Left(currentTable.Title, 7) = "Chapter" Then  ' Process all Chapter tables
            For masterRowIndex = 2 To currentTable.Rows.Count
                currentCode = Trim(Replace(currentTable.Cell(masterRowIndex, 1).Range.Text, vbCr & Chr(7), ""))
                If Len(currentCode) > 0 Then masterCodeMap(currentCode) = masterRowIndex
            Next
        End If
    Next

    ' Get evaluation worksheet
    Set evaluationWorksheet = ThisWorkbook.Sheets("SelbstbeurteilungKunde")

    ' Process Chapter 1 only (for now)
    ProcessSingleChapter 1, masterDocument, reportDocument, masterCodeMap, evaluationWorksheet

    ' Save document
    saveDirectory = Left$(originalReportPath, InStrRev(originalReportPath, "\") - 1)
    saveFileName = "IST-Aufnahme-Bericht_" & Format(Now(), "yyyy-mm-dd_HHmm") & ".docx"
    reportDocument.SaveAs2 fileName:=saveDirectory & "\" & saveFileName, FileFormat:=wdFormatDocumentDefault
    
    MsgBox "Report completed successfully!" & vbCrLf & "Saved as: " & saveFileName, vbInformation
End Sub

'===================================================================
' Future procedure - will process all chapters 1-14
'===================================================================
Public Sub ImportAllChapters()
    ' This will be implemented later
    ' Will loop through chapters 1 to 14
    ' For chapterNumber = 1 To 14
    '     ProcessSingleChapter chapterNumber, masterDocument, reportDocument, masterCodeMap, evaluationWorksheet
    ' Next chapterNumber
End Sub

--------------------------------------------------

### MODULE CODE: Utilities
==================================================
Sub ExportAllVBA()
    Dim VBComp As Object
    Dim VBProj As Object
    Dim CodeMod As Object
    Dim FileNum As Integer
    Dim i As Long
    Dim ExportPath As String
    Dim CurrentDate As String
    Dim folderPath As String
    Dim fd As fileDialog
    Dim FolderSelected As Boolean
    
    On Error GoTo ErrorHandler
    
    ' Get the current date in yyyy-mm-dd format
    CurrentDate = Format(Date, "yyyy-mm-dd")
    
    ' Set reference to the VBA project
    Set VBProj = ThisWorkbook.VBProject
    
    ' Prompt user to select a folder
    Set fd = Application.fileDialog(msoFileDialogFolderPicker)
    fd.Title = "Select Folder to Save Exported VBA Code"
    FolderSelected = fd.Show
    
    If FolderSelected = -1 Then
        folderPath = fd.SelectedItems(1)
    Else
        MsgBox "Export cancelled. No folder selected.", vbExclamation
        Exit Sub
    End If
    
    ' Define the export path with the current date prepended
    ExportPath = folderPath & "\" & CurrentDate & "_ExportedVBA.txt"
    
    ' Create or open the output file
    FileNum = FreeFile
    Open ExportPath For Output As #FileNum
    
    ' Loop through each component in the project
    For Each VBComp In VBProj.VBComponents
        ' Skip the current macro module
        If VBComp.Name = "ModuleName" Then ' Replace "ModuleName" with the name of the module containing this code
            Set CodeMod = VBComp.CodeModule
            For i = 1 To CodeMod.CountOfLines
                ' Skip the current procedure
                If Not InStr(1, CodeMod.Lines(i, 1), "Sub ExportAllVBA", vbTextCompare) > 0 Then
                    Exit For
                End If
            Next i
        End If

        ' Check the type of component and write the appropriate header
        Select Case VBComp.Type
            Case 1 ' Standard module
                Print #FileNum, "### MODULE CODE: " & VBComp.Name
            Case 2 ' Class module
                Print #FileNum, "### CLASS MODULE CODE: " & VBComp.Name
            Case 3 ' User form
                Print #FileNum, "### FORM CODE: " & VBComp.Name
            Case Else ' Sheet or ThisWorkbook
                Print #FileNum, "### SHEET/WORKBOOK CODE: " & VBComp.Name
        End Select
        Print #FileNum, String(50, "=")
        
        ' Set reference to the code module
        Set CodeMod = VBComp.CodeModule
        
        ' Loop through each line of code in the module
        For i = 1 To CodeMod.CountOfLines
            ' Exclude the current macro
            If Not (VBComp.Name = "ModuleName" And InStr(1, CodeMod.Lines(i, 1), "Sub ExportAllVBA", vbTextCompare) > 0) Then ' Replace "ModuleName" with the name of the module containing this code
                Print #FileNum, CodeMod.Lines(i, 1)
            End If
        Next i
        
        ' Add a separator for readability
        Print #FileNum, String(50, "-")
        Print #FileNum, ""
    Next VBComp
    
    ' Close the output file
    Close #FileNum
    
    ' Notify the user
    MsgBox "Export complete. The code has been saved to '" & ExportPath & "'.", vbInformation
    Exit Sub
    
ErrorHandler:
    If FileNum <> 0 Then Close #FileNum
    MsgBox "Error " & Err.Number & ": " & Err.description, vbCritical
End Sub

--------------------------------------------------

### FORM CODE: BerichtForm
==================================================
Option Explicit

' ---------- Config ----------
' Child names inside RowTemplate (must match your control Names)
Private Const CN_LineNumber        As String = "LblLine"
Private Const CN_ReportItemID      As String = "LblID"
Private Const CN_AntwortKunde      As String = "LblAntwort"

Private Const CN_Bericht           As String = "ChkInclude"             ' checkbox "In Bericht"
Private Const CN_Opt1              As String = "Opt1"
Private Const CN_Opt2              As String = "Opt2"
Private Const CN_Opt3              As String = "Opt3"
Private Const CN_Opt4              As String = "Opt4"

Private Const CN_FestMaster        As String = "TxtFestMaster"          ' read-only Feststellung preview
Private Const CN_LevelMaster       As String = "TxtLevelMaster"         ' (spelling per your control)

Private Const CN_FestEdit          As String = "TxtFestEdit"            ' editable Feststellung
Private Const CN_LevelEdit         As String = "TxtLevelEdit"           ' editable Level (recommendation)

Private Const CN_UseFestOverride   As String = "ChkUseFestOverride"
Private Const CN_UseLevelOverride  As String = "ChkUseLevelOverride"
Private Const CN_BtnPromote        As String = "BtnPromoteMaster"       ' optional

' Layout
Private Const ROW_HEIGHT As Single = 180   ' adjust after first run
Private Const ROW_GAP    As Single = 8
Private Const START_TOP  As Single = 8

' TEMP: cap rows while stabilizing (set to 0 to disable)
Private Const MAX_ROWS As Long = 0

Private RowFrames As Collection  ' names of cloned row frames

' ---------- State ----------
Private didRender As Boolean
Private rowSeq As Long
Private ctlSeq As Long
Private RowUIs As Collection
Private currentChapter As Long

' ---------- Lifecycle ----------
Private Sub UserForm_Initialize()
    ' Load caches only; do not render yet (avoid MSForms timing crash)
    modReportData.LoadAllCaches
    currentChapter = 1
End Sub

Private Sub UserForm_Activate()
    If Not didRender Then
        didRender = True
        RenderChapter currentChapter
    End If
End Sub

' ---------- Rendering ----------
Private Sub RenderChapter(ByVal chapterNumber As Long)
    On Error GoTo FAIL

    ClearAllRowsOnForm
    Set RowUIs = New Collection
    rowSeq = 0
    
    Set RowFrames = New Collection

    Dim lo As ListObject, r As ListRow
    Dim id As String
    Dim s As modReportData.SBRow
    Dim y As Single: y = START_TOP
    Dim lineNo As Long: lineNo = 1

    Set lo = ThisWorkbook.Worksheets("SelbstbeurteilungKunde").ListObjects("TableSelbstbeurteilung")

    Dim prefix As String: prefix = CStr(chapterNumber) & "."
    Debug.Print "RenderChapter start | chapter:", chapterNumber, "| SB rows:", lo.ListRows.Count

    Dim countRendered As Long: countRendered = 0

    For Each r In lo.ListRows
        id = modReportData.CleanID(CStr(r.Range.Cells(1, 1).Value))
        If Len(id) > 0 Then
            If Left$(id, Len(prefix)) = prefix Then
                s = modReportData.GetSB(id)

                ' --- clone one row ---
                Dim fra As MSForms.Frame
                Set fra = CloneRowTemplate(Me, y)   ' host is the form
                Debug.Print "  cloned frame for:", id

                ' --- fill labels ---
                Dim lbl As MSForms.Label
                Dim txt As MSForms.TextBox
                Dim chk As MSForms.CheckBox

                Set lbl = FindLabel(fra, CN_LineNumber):   If Not lbl Is Nothing Then lbl.caption = CStr(lineNo)
                Set lbl = FindLabel(fra, CN_ReportItemID): If Not lbl Is Nothing Then lbl.caption = id
                Set lbl = FindLabel(fra, CN_AntwortKunde): If Not lbl Is Nothing Then lbl.caption = s.antwort

                ' --- master previews ---
                Set txt = FindTextBox(fra, CN_FestMaster)
                If Not txt Is Nothing Then
                    txt.Locked = True
                    txt.Text = modReportData.GetMasterFinding(id)
                End If

                Set txt = FindTextBox(fra, CN_LevelMaster)
                If Not txt Is Nothing Then
                    txt.Locked = True
                    txt.Text = modReportData.GetMasterLevelText(id, IIf(s.SelectedLevel = 0, 1, s.SelectedLevel))
                End If

                ' --- selected checkbox ---
                Set chk = FindCheckBox(fra, CN_Bericht)
                If Not chk Is Nothing Then chk.Value = s.selected

                ' --- wire events ---
                Dim row As New CRowUI
                Set row.LblLine = FindLabel(fra, CN_LineNumber)
                Set row.LblID = FindLabel(fra, CN_ReportItemID)
                Set row.LblAntwort = FindLabel(fra, CN_AntwortKunde)
                Set row.ChkInclude = FindCheckBox(fra, CN_Bericht)
                Set row.Opt1 = FindOption(fra, CN_Opt1)
                Set row.Opt2 = FindOption(fra, CN_Opt2)
                Set row.Opt3 = FindOption(fra, CN_Opt3)
                Set row.Opt4 = FindOption(fra, CN_Opt4)
                Set row.TxtFestMaster = FindTextBox(fra, CN_FestMaster)
                Set row.TxtLevelMaster = FindTextBox(fra, CN_LevelMaster)
                Set row.TxtFestEdit = FindTextBox(fra, CN_FestEdit)
                Set row.TxtLevelEdit = FindTextBox(fra, CN_LevelEdit)
                Set row.ChkUseFestOverride = FindCheckBox(fra, CN_UseFestOverride)
                Set row.ChkUseLevelOverride = FindCheckBox(fra, CN_UseLevelOverride)
                On Error Resume Next
                Set row.BtnPromoteMaster = FindButton(fra, CN_BtnPromote)
                On Error GoTo 0

                Dim initLevel As Long: initLevel = IIf(s.SelectedLevel = 0, 1, s.SelectedLevel)
                row.Init id, s.antwort, s.selected, initLevel, _
                         modReportData.GetMasterFinding(id), modReportData.GetMasterLevelText(id, initLevel)

                RowUIs.Add row

                y = y + ROW_HEIGHT + ROW_GAP
                lineNo = lineNo + 1
                countRendered = countRendered + 1
                If MAX_ROWS > 0 And countRendered >= MAX_ROWS Then Exit For
            End If
        End If
    Next

    ' Scroll the form itself
    Me.ScrollBars = fmScrollBarsVertical
    Me.ScrollHeight = y + 20
    Debug.Print "RenderChapter done | rendered:", countRendered
    Exit Sub

FAIL:
    MsgBox "RenderChapter failed: " & Err.description, vbCritical
End Sub


' ---------- Clone template into the form ----------
Private Function CloneRowTemplate(ByVal hostForm As Object, ByVal topY As Single) As MSForms.Frame
    On Error GoTo EH

    Dim tpl As MSForms.Frame
    Set tpl = Me.Controls("RowTemplate")   ' template is directly on the form

    ' clone into the same parent the template uses (the form)
    Dim container As Object
    Set container = tpl.parent

    Dim fra As MSForms.Frame
    Set fra = container.Controls.Add("Forms.Frame.1")
    fra.Left = tpl.Left
    fra.Top = topY
    fra.Width = tpl.Width
    fra.Height = tpl.Height
    fra.caption = ""
    fra.Tag = "ROWFRAME"
    
    rowSeq = rowSeq + 1
    ctlSeq = 0

    Dim ctl As MSForms.Control, dst As MSForms.Control

    For Each ctl In tpl.Controls
        ' Handle MultiPage specially (clone pages, then their children)
        If TypeName(ctl) = "MultiPage" Then
            Set dst = CloneMultiPage(ctl, fra)    ' returns the new MultiPage control
            ' name + tag
            ctlSeq = ctlSeq + 1
            dst.Tag = ctl.Name
            dst.Name = ctl.Name & "_" & rowSeq & "_" & ctlSeq
            RowFrames.Add fra.Name

        Else
            Dim pid As String: pid = ProgIDFor(ctl)
            If Len(pid) > 0 Then
                On Error GoTo ADDFAIL
                Set dst = fra.Controls.Add(pid)
                SafeCopy ctl, dst
                ctlSeq = ctlSeq + 1
                dst.Tag = ctl.Name
                dst.Name = ctl.Name & "_" & rowSeq & "_" & ctlSeq
                If TypeName(dst) = "OptionButton" Then
                    ' ensure per-row grouping
                    Dim ob As MSForms.OptionButton
                    Set ob = dst
                    ob.GroupName = "grpLevel_" & rowSeq
                End If
                On Error GoTo EH
            Else
                ' Unknown control type ? skip
                Debug.Print "skip type:", TypeName(ctl), " name:", ctl.Name
            End If
        End If
    Next
    
    Set CloneRowTemplate = fra
    Exit Function

ADDFAIL:
    Debug.Print "clone-skip:", TypeName(ctl), ctl.Name, Err.description
    Err.Clear
    Resume Next

EH:
    If Err.Number <> 0 Then MsgBox "CloneRowTemplate error: " & Err.description, vbCritical
End Function

' Clone a MultiPage (pages + children) into a parent frame; returns the new MultiPage
Private Function CloneMultiPage(ByVal srcMP As MSForms.MultiPage, ByVal parentFrame As MSForms.Frame) As MSForms.MultiPage
    On Error GoTo EH

    Dim dstMP As MSForms.MultiPage
    Set dstMP = parentFrame.Controls.Add("Forms.MultiPage.1")

    ' basic geometry
    dstMP.Left = srcMP.Left
    dstMP.Top = srcMP.Top
    dstMP.Width = srcMP.Width
    dstMP.Height = srcMP.Height
    dstMP.Visible = True

    ' Remove default pages, we’ll rebuild exactly
    Do While dstMP.Pages.Count > 0
        dstMP.Pages.Remove 0
    Loop

    ' Clone pages
    Dim p As Integer
    For p = 0 To srcMP.Pages.Count - 1
        Dim srcPg As MSForms.page, dstPg As MSForms.page
        Set srcPg = srcMP.Pages(p)
        dstMP.Pages.Add
        Set dstPg = dstMP.Pages(dstMP.Pages.Count - 1)
        dstPg.caption = srcPg.caption

        ' Clone page children into this page
        Dim c As MSForms.Control, nc As MSForms.Control
        For Each c In srcPg.Controls
            Dim pid As String: pid = ProgIDFor(c)
            If Len(pid) > 0 Then
                On Error Resume Next
                Set nc = dstPg.Controls.Add(pid)
                If Err.Number <> 0 Then
                    Debug.Print "page clone-skip:", TypeName(c), c.Name, Err.description
                    Err.Clear
                Else
                    SafeCopy c, nc
                    ctlSeq = ctlSeq + 1
                    nc.Tag = c.Name
                    nc.Name = c.Name & "_" & rowSeq & "_" & ctlSeq
                    If TypeName(nc) = "OptionButton" Then
                        Dim ob As MSForms.OptionButton
                        Set ob = nc
                        ob.GroupName = "grpLevel_" & rowSeq   ' keep per-row grouping
                    End If
                End If
                On Error GoTo 0
            Else
                Debug.Print "page skip type:", TypeName(c), c.Name
            End If
        Next c
    Next p

    Set CloneMultiPage = dstMP
    Exit Function

EH:
    MsgBox "CloneMultiPage error: " & Err.description, vbCritical
End Function


Private Function ProgIDFor(ByVal ctl As MSForms.Control) As String
    Select Case TypeName(ctl)
        Case "Label":         ProgIDFor = "Forms.Label.1"
        Case "TextBox":       ProgIDFor = "Forms.TextBox.1"
        Case "CheckBox":      ProgIDFor = "Forms.CheckBox.1"
        Case "OptionButton":  ProgIDFor = "Forms.OptionButton.1"
        Case "CommandButton": ProgIDFor = "Forms.CommandButton.1"
        Case "Frame":         ProgIDFor = "Forms.Frame.1"
        Case "MultiPage":     ProgIDFor = "Forms.MultiPage.1"
        Case Else:            ProgIDFor = ""  ' skip others (Image/ComboBox/TabStrip, etc.) for now
    End Select
End Function

Private Sub SafeCopy(ByVal src As MSForms.Control, ByVal dst As MSForms.Control)
    On Error Resume Next
    dst.Left = src.Left
    dst.Top = src.Top
    dst.Width = src.Width
    dst.Height = src.Height
    dst.Visible = True

    Select Case TypeName(src)
        Case "Label"
            dst.caption = src.caption

        Case "TextBox"
            dst.Text = ""
            dst.MultiLine = True
            dst.EnterKeyBehavior = True
            dst.ScrollBars = fmScrollBarsVertical

        Case "CheckBox", "OptionButton"
            dst.caption = src.caption
            dst.Value = False

        Case "CommandButton"
            dst.caption = src.caption

        Case "Frame"
            dst.caption = ""

        Case "MultiPage"
            ' handled by CloneMultiPage (do not copy here)
    End Select
    On Error GoTo 0
End Sub



' ========== RECURSIVE FINDERS: match by Tag OR Name ==========

Private Function FindLabel(ByVal parent As MSForms.Frame, ByVal key As String) As MSForms.Label
    Dim c As MSForms.Control
    For Each c In parent.Controls
        If TypeName(c) = "Label" Then
            If StrComp(c.Tag, key, vbTextCompare) = 0 Or StrComp(c.Name, key, vbTextCompare) = 0 Then
                Set FindLabel = c: Exit Function
            End If
        ElseIf TypeName(c) = "Frame" Then
            Set FindLabel = FindLabel(c, key): If Not FindLabel Is Nothing Then Exit Function
        ElseIf TypeName(c) = "MultiPage" Then
            Dim mp As MSForms.MultiPage, pg As MSForms.page
            Set mp = c
            For Each pg In mp.Pages
                Set FindLabel = FindLabelInPage(pg, key): If Not FindLabel Is Nothing Then Exit Function
            Next
        End If
    Next
End Function
Private Function FindLabelInPage(ByVal page As MSForms.page, ByVal key As String) As MSForms.Label
    Dim c As MSForms.Control
    For Each c In page.Controls
        If TypeName(c) = "Label" Then
            If StrComp(c.Tag, key, vbTextCompare) = 0 Or StrComp(c.Name, key, vbTextCompare) = 0 Then
                Set FindLabelInPage = c: Exit Function
            End If
        ElseIf TypeName(c) = "Frame" Then
            Set FindLabelInPage = FindLabel(c, key): If Not FindLabelInPage Is Nothing Then Exit Function
        End If
    Next
End Function

Private Function FindTextBox(ByVal parent As MSForms.Frame, ByVal key As String) As MSForms.TextBox
    Dim c As MSForms.Control
    For Each c In parent.Controls
        If TypeName(c) = "TextBox" Then
            If StrComp(c.Tag, key, vbTextCompare) = 0 Or StrComp(c.Name, key, vbTextCompare) = 0 Then
                Set FindTextBox = c: Exit Function
            End If
        ElseIf TypeName(c) = "Frame" Then
            Set FindTextBox = FindTextBox(c, key): If Not FindTextBox Is Nothing Then Exit Function
        ElseIf TypeName(c) = "MultiPage" Then
            Dim mp As MSForms.MultiPage, pg As MSForms.page
            Set mp = c
            For Each pg In mp.Pages
                Set FindTextBox = FindTextBoxInPage(pg, key): If Not FindTextBox Is Nothing Then Exit Function
            Next
        End If
    Next
End Function
Private Function FindTextBoxInPage(ByVal page As MSForms.page, ByVal key As String) As MSForms.TextBox
    Dim c As MSForms.Control
    For Each c In page.Controls
        If TypeName(c) = "TextBox" Then
            If StrComp(c.Tag, key, vbTextCompare) = 0 Or StrComp(c.Name, key, vbTextCompare) = 0 Then
                Set FindTextBoxInPage = c: Exit Function
            End If
        ElseIf TypeName(c) = "Frame" Then
            Set FindTextBoxInPage = FindTextBox(c, key): If Not FindTextBoxInPage Is Nothing Then Exit Function
        End If
    Next
End Function

Private Function FindCheckBox(ByVal parent As MSForms.Frame, ByVal key As String) As MSForms.CheckBox
    Dim c As MSForms.Control
    For Each c In parent.Controls
        If TypeName(c) = "CheckBox" Then
            If StrComp(c.Tag, key, vbTextCompare) = 0 Or StrComp(c.Name, key, vbTextCompare) = 0 Then
                Set FindCheckBox = c: Exit Function
            End If
        ElseIf TypeName(c) = "Frame" Then
            Set FindCheckBox = FindCheckBox(c, key): If Not FindCheckBox Is Nothing Then Exit Function
        ElseIf TypeName(c) = "MultiPage" Then
            Dim mp As MSForms.MultiPage, pg As MSForms.page
            Set mp = c
            For Each pg In mp.Pages
                Set FindCheckBox = FindCheckBoxInPage(pg, key): If Not FindCheckBox Is Nothing Then Exit Function
            Next
        End If
    Next
End Function
Private Function FindCheckBoxInPage(ByVal page As MSForms.page, ByVal key As String) As MSForms.CheckBox
    Dim c As MSForms.Control
    For Each c In page.Controls
        If TypeName(c) = "CheckBox" Then
            If StrComp(c.Tag, key, vbTextCompare) = 0 Or StrComp(c.Name, key, vbTextCompare) = 0 Then
                Set FindCheckBoxInPage = c: Exit Function
            End If
        ElseIf TypeName(c) = "Frame" Then
            Set FindCheckBoxInPage = FindCheckBox(c, key): If Not FindCheckBoxInPage Is Nothing Then Exit Function
        End If
    Next
End Function

Private Function FindOption(ByVal parent As MSForms.Frame, ByVal key As String) As MSForms.OptionButton
    Dim c As MSForms.Control
    For Each c In parent.Controls
        If TypeName(c) = "OptionButton" Then
            If StrComp(c.Tag, key, vbTextCompare) = 0 Or StrComp(c.Name, key, vbTextCompare) = 0 Then
                Set FindOption = c: Exit Function
            End If
        ElseIf TypeName(c) = "Frame" Then
            Set FindOption = FindOption(c, key): If Not FindOption Is Nothing Then Exit Function
        ElseIf TypeName(c) = "MultiPage" Then
            Dim mp As MSForms.MultiPage, pg As MSForms.page
            Set mp = c
            For Each pg In mp.Pages
                Set FindOption = FindOptionInPage(pg, key): If Not FindOption Is Nothing Then Exit Function
            Next
        End If
    Next
End Function
Private Function FindOptionInPage(ByVal page As MSForms.page, ByVal key As String) As MSForms.OptionButton
    Dim c As MSForms.Control
    For Each c In page.Controls
        If TypeName(c) = "OptionButton" Then
            If StrComp(c.Tag, key, vbTextCompare) = 0 Or StrComp(c.Name, key, vbTextCompare) = 0 Then
                Set FindOptionInPage = c: Exit Function
            End If
        ElseIf TypeName(c) = "Frame" Then
            Set FindOptionInPage = FindOption(c, key): If Not FindOptionInPage Is Nothing Then Exit Function
        End If
    Next
End Function

Private Function FindButton(ByVal parent As MSForms.Frame, ByVal key As String) As MSForms.CommandButton
    Dim c As MSForms.Control
    For Each c In parent.Controls
        If TypeName(c) = "CommandButton" Then
            If StrComp(c.Tag, key, vbTextCompare) = 0 Or StrComp(c.Name, key, vbTextCompare) = 0 Then
                Set FindButton = c: Exit Function
            End If
        ElseIf TypeName(c) = "Frame" Then
            Set FindButton = FindButton(c, key): If Not FindButton Is Nothing Then Exit Function
        ElseIf TypeName(c) = "MultiPage" Then
            Dim mp As MSForms.MultiPage, pg As MSForms.page
            Set mp = c
            For Each pg In mp.Pages
                Set FindButton = FindButtonInPage(pg, key): If Not FindButton Is Nothing Then Exit Function
            Next
        End If
    Next
End Function
Private Function FindButtonInPage(ByVal page As MSForms.page, ByVal key As String) As MSForms.CommandButton
    Dim c As MSForms.Control
    For Each c In page.Controls
        If TypeName(c) = "CommandButton" Then
            If StrComp(c.Tag, key, vbTextCompare) = 0 Or StrComp(c.Name, key, vbTextCompare) = 0 Then
                Set FindButtonInPage = c: Exit Function
            End If
        ElseIf TypeName(c) = "Frame" Then
            Set FindButtonInPage = FindButton(c, key): If Not FindButtonInPage Is Nothing Then Exit Function
        End If
    Next
End Function

' ---------- Clear all cloned rows ----------
' Remove only the cloned row frames we created last time
Private Sub ClearAllRowsOnForm()
    On Error Resume Next
    Dim i As Long, nm As String
    If Not RowFrames Is Nothing Then
        For i = RowFrames.Count To 1 Step -1
            nm = RowFrames(i)
            ' remove from the same parent as the template (the form)
            If ControlExistsOnForm(nm) Then Me.Controls.Remove nm
        Next
        Set RowFrames = Nothing
    End If
    On Error GoTo 0
End Sub

Private Function ControlExistsOnForm(ByVal ctlName As String) As Boolean
    Dim c As MSForms.Control
    For Each c In Me.Controls
        If StrComp(c.Name, ctlName, vbTextCompare) = 0 Then ControlExistsOnForm = True: Exit Function
    Next
End Function

Private Sub Debug_DumpFirstRowTags(f As MSForms.Frame)
    Debug.Print "---- Dump tags/names in row frame:", f.Name
    Dim q As Collection: Set q = New Collection
    q.Add f
    Do While q.Count > 0
        Dim x As Object: Set x = q(1): q.Remove 1
        Dim c As MSForms.Control
        For Each c In x.Controls
            Debug.Print TypeName(c), "  Name=", c.Name, "  Tag=", c.Tag
            If TypeName(c) = "Frame" Then q.Add c
            If TypeName(c) = "MultiPage" Then
                Dim mp As MSForms.MultiPage, pg As MSForms.page
                Set mp = c
                For Each pg In mp.Pages: q.Add pg: Next
            End If
        Next
    Loop
End Sub



--------------------------------------------------

### SHEET/WORKBOOK CODE: Sheet7
==================================================
--------------------------------------------------

### SHEET/WORKBOOK CODE: Sheet8
==================================================
--------------------------------------------------

### SHEET/WORKBOOK CODE: Sheet9
==================================================
--------------------------------------------------

### MODULE CODE: ImportMyMaster
==================================================
Option Explicit

' ================================================================
' Import MyMaster from DOCX with STRICT headers (first row only)
'   Required headers (exact tokens, case-insensitive):
'     ReportItemID | Feststellung | Level1 | Level2 | Level3 | Level4
'   Sheet/Table required:
'     Sheet "MyMaster" with Table "TableMyMaster"
'     Columns: ReportItemID, Feststellung, Level1, Level2, Level3, Level4
' ================================================================
Public Sub ImportMyMaster()
    Const CLEAR_EXISTING As Boolean = True ' set False to append/update

    Dim ws As Worksheet, lo As ListObject
    Dim fd As fileDialog, docPath As String
    Dim wApp As Object, wDoc As Object, wTbl As Object
    Dim imported As Long, updated As Long

    ' Locate Excel table
    On Error Resume Next
    Set ws = ThisWorkbook.Worksheets("MyMaster")
    Set lo = ws.ListObjects("TableMyMaster")
    On Error GoTo 0
    If lo Is Nothing Then
        MsgBox "Excel table 'TableMyMaster' not found on sheet 'MyMaster'." & vbCrLf & _
               "Create it with columns: ReportItemID, Feststellung, Level1, Level2, Level3, Level4.", vbCritical
        Exit Sub
    End If
    If Not HeadersMatchExcel(lo) Then
        MsgBox "TableMyMaster columns must be exactly:" & vbCrLf & _
               "ReportItemID, Feststellung, Level1, Level2, Level3, Level4", vbCritical
        Exit Sub
    End If

    ' Pick DOCX
    Set fd = Application.fileDialog(msoFileDialogFilePicker)
    With fd
        .Title = "Select Master DOCX (MyMaster source)"
        .Filters.Clear
        .Filters.Add "Word Documents", "*.docx;*.docm;*.doc"
        If .Show <> -1 Then Exit Sub
        docPath = .SelectedItems(1)
    End With

    ' Start Word (late binding)
    On Error Resume Next
    Set wApp = CreateObject("Word.Application")
    On Error GoTo 0
    If wApp Is Nothing Then
        MsgBox "Could not start Microsoft Word.", vbCritical
        Exit Sub
    End If
    wApp.Visible = False

    On Error GoTo CLEANUP
    Set wDoc = wApp.Documents.Open(fileName:=docPath, ReadOnly:=True, AddToRecentFiles:=False)

    ' Build index of existing IDs if appending/updating
    Dim idRowIndex As Object: Set idRowIndex = CreateObject("Scripting.Dictionary")
    If Not lo.DataBodyRange Is Nothing Then
        Dim r As Long, last As Long: last = lo.DataBodyRange.Rows.Count
        Dim k$: For r = 1 To last
            k = CStr(lo.DataBodyRange.Cells(r, 1).Value)
            If Len(k) > 0 Then idRowIndex(k) = r
        Next r
    End If

    ' Clear existing data if desired
    If CLEAR_EXISTING Then
        If Not lo.DataBodyRange Is Nothing Then lo.DataBodyRange.Delete
        idRowIndex.RemoveAll
    End If

    ' Scan Word tables strictly
    Dim idxID&, idxFest&, idxL1&, idxL2&, idxL3&, idxL4&
    Dim insThis As Long, updThis As Long
    imported = 0: updated = 0

    For Each wTbl In wDoc.Tables
        If DetectExactHeadersStrict(wTbl, idxID, idxFest, idxL1, idxL2, idxL3, idxL4) Then
            ImportOneStrict wTbl, idxID, idxFest, idxL1, idxL2, idxL3, idxL4, lo, idRowIndex, insThis, updThis
            imported = imported + insThis
            updated = updated + updThis
        End If
    Next

    If imported = 0 And updated = 0 Then
        MsgBox "No compatible tables found in Word with exact headers on row 1." & vbCrLf & _
               "Open the Immediate Window (Ctrl+G) to see detected headers per table.", vbExclamation
    Else
        MsgBox "MyMaster import complete." & vbCrLf & _
               "Inserted: " & imported & "   Updated: " & updated, vbInformation
    End If

CLEANUP:
    On Error Resume Next
    If Not wDoc Is Nothing Then wDoc.Close SaveChanges:=False
    If Not wApp Is Nothing Then wApp.Quit
    Set wDoc = Nothing: Set wApp = Nothing
End Sub

' ---------- Helpers (STRICT) ----------

Private Function HeadersMatchExcel(lo As ListObject) As Boolean
    ' Expect exactly 6 columns in order:
    ' ReportItemID, Feststellung, Level1, Level2, Level3, Level4
    If lo.ListColumns.Count <> 6 Then Exit Function
    HeadersMatchExcel = ( _
        SameToken(lo.ListColumns(1).Name, "ReportItemID") And _
        SameToken(lo.ListColumns(2).Name, "Feststellung") And _
        SameToken(lo.ListColumns(3).Name, "Level1") And _
        SameToken(lo.ListColumns(4).Name, "Level2") And _
        SameToken(lo.ListColumns(5).Name, "Level3") And _
        SameToken(lo.ListColumns(6).Name, "Level4"))
End Function

Private Function DetectExactHeadersStrict(ByVal tbl As Object, _
    ByRef idxID As Long, ByRef idxFest As Long, _
    ByRef idxL1 As Long, ByRef idxL2 As Long, ByRef idxL3 As Long, ByRef idxL4 As Long) As Boolean

    Dim c As Long, hdr As String
    idxID = 0: idxFest = 0: idxL1 = 0: idxL2 = 0: idxL3 = 0: idxL4 = 0
    If tbl.Rows.Count = 0 Then Exit Function

    ' Print the headers we see (helps debugging if it fails)
    Dim hdrDebug As String: hdrDebug = ""

    For c = 1 To tbl.Columns.Count
        hdr = CleanHeader(GetCellText(tbl.Cell(1, c)))
        hdrDebug = hdrDebug & IIf(hdrDebug = "", "", " | ") & hdr
        Select Case True
            Case SameToken(hdr, "ReportItemID"): idxID = c
            Case SameToken(hdr, "Feststellung"): idxFest = c
            Case SameToken(hdr, "Level1"): idxL1 = c
            Case SameToken(hdr, "Level2"): idxL2 = c
            Case SameToken(hdr, "Level3"): idxL3 = c
            Case SameToken(hdr, "Level4"): idxL4 = c
        End Select
    Next c

    Debug.Print "Table headers (row1): "; hdrDebug

    DetectExactHeadersStrict = (idxID > 0 And idxFest > 0 And idxL1 > 0 And idxL2 > 0 And idxL3 > 0 And idxL4 > 0)
End Function

Private Sub ImportOneStrict(ByVal tbl As Object, _
    ByVal idxID As Long, ByVal idxFest As Long, _
    ByVal idxL1 As Long, ByVal idxL2 As Long, ByVal idxL3 As Long, ByVal idxL4 As Long, _
    ByVal lo As ListObject, ByVal idRowIndex As Object, _
    ByRef insertedOut As Long, ByRef updatedOut As Long)

    Dim r As Long, lastR As Long
    Dim idRaw$, id$, fest$, l1$, l2$, l3$, l4$
    insertedOut = 0: updatedOut = 0
    lastR = tbl.Rows.Count
    If lastR < 2 Then Exit Sub ' no data

    For r = 2 To lastR
        idRaw = CleanHeader(GetCellText(tbl.Cell(r, idxID))) ' reuse CleanHeader to strip NBSP/CR/chr(7)
        If Len(idRaw) = 0 Then
            ' Layout-only row ? skip
        Else
            id = NormalizeReportItemID(idRaw)  ' strip trailing dots/spaces, collapse ..
            If IsValidReportItemID_Lax(id) Then
                ' Keep row even if texts are blank
                fest = CleanBody(GetCellText(tbl.Cell(r, idxFest)))
                l1 = CleanBody(GetCellText(tbl.Cell(r, idxL1)))
                l2 = CleanBody(GetCellText(tbl.Cell(r, idxL2)))
                l3 = CleanBody(GetCellText(tbl.Cell(r, idxL3)))
                l4 = CleanBody(GetCellText(tbl.Cell(r, idxL4)))

                If idRowIndex.Exists(id) Then
                    Dim erow&: erow = idRowIndex(id)
                    With lo.DataBodyRange.Rows(erow)
                        .Cells(1, 1).Value = id
                        .Cells(1, 2).Value = fest
                        .Cells(1, 3).Value = l1
                        .Cells(1, 4).Value = l2
                        .Cells(1, 5).Value = l3
                        .Cells(1, 6).Value = l4
                    End With
                    updatedOut = updatedOut + 1
                Else
                    Dim newRow As ListRow
                    Set newRow = lo.ListRows.Add
                    With newRow.Range
                        .Cells(1, 1).Value = id
                        .Cells(1, 2).Value = fest
                        .Cells(1, 3).Value = l1
                        .Cells(1, 4).Value = l2
                        .Cells(1, 5).Value = l3
                        .Cells(1, 6).Value = l4
                    End With
                    idRowIndex(id) = newRow.index
                    insertedOut = insertedOut + 1
                End If
            Else
                ' Not a valid ID (e.g., "Kapitel") ? skip
            End If
        End If
    Next r
End Sub

' -------- text/ID helpers --------

Private Function GetCellText(ByVal cellObj As Object) As String
    ' Word table cell text ends with Chr(13) & Chr(7)
    Dim s$: s = cellObj.Range.Text
    s = Replace$(s, Chr$(13), vbLf)
    s = Replace$(s, Chr$(7), "")
    GetCellText = s
End Function

Private Function CleanHeader(ByVal s As String) As String
    ' Strict header cleaner: remove control chars and NBSP, trim spaces; do NOT alter words
    s = Replace$(s, vbCr, vbLf)
    s = Replace$(s, vbLf, " ")
    s = Replace$(s, vbTab, " ")
    s = Replace$(s, Chr$(160), " ") ' NBSP
    Do While InStr(s, "  ") > 0
        s = Replace$(s, "  ", " ")
    Loop
    CleanHeader = Trim$(s)
End Function

Private Function SameToken(ByVal a As String, ByVal b As String) As Boolean
    SameToken = (LCase$(CleanHeader(a)) = LCase$(b))
End Function

Private Function CleanBody(ByVal s As String) As String
    ' Keep content; normalize line breaks; trim
    s = Replace$(s, vbCr, vbLf)
    s = Trim$(s)
    CleanBody = s
End Function

Private Function NormalizeReportItemID(ByVal s As String) As String
    ' Canonicalize: strip trailing dots/spaces, collapse double dots
    Dim t$: t = Trim$(s)
    Do While Len(t) > 0 And (Right$(t, 1) = "." Or Right$(t, 1) = " ")
        t = Left$(t, Len(t) - 1)
    Loop
    Do While InStr(t, "..") > 0
        t = Replace$(t, "..", ".")
    Loop
    NormalizeReportItemID = t
End Function

Private Function IsValidReportItemID_Lax(ByVal s As String) As Boolean
    ' Accept IDs with >=1 segments: 1, 1.1, 1.1.1, 2.3.4.5, and with optional a/b suffixes
    Dim parts() As String, i&, seg$
    If Len(s) = 0 Then Exit Function
    parts = Split(s, ".")
    If UBound(parts) < 0 Then Exit Function ' need at least "1"
    For i = LBound(parts) To UBound(parts)
        seg = parts(i)
        If Len(seg) = 0 Then Exit Function
        ' allow digits with optional trailing letters (e.g., "1", "1a")
        ' reject blatant non-IDs like "Kapitel"
        If Not seg Like "*[0-9]*" Then Exit Function
    Next i
    IsValidReportItemID_Lax = True
End Function


--------------------------------------------------

### MODULE CODE: modReportData
==================================================
'=================  modReportData.bas  =================
Option Explicit

' Intent: centralize table access and resolver logic (Master ? Override)
' Tables (Excel ListObjects):
'   - MyMaster!TableMyMaster         (ReportItemID, Feststellung, Level1..Level4)
'   - ReportOverrides!TableOverrides (ReportItemID, Component, LevelNum, OverrideText, Status, LastEdited, PromotedtoMaster, [EditedBy])
'   - SelbstbeurteilungKunde!TableSelbstbeurteilung
'       (ReportItemID, …, AntwortKunde, BemerkungKunde or Bemerkungen des Kunden, Selected, SelectedLevel)

Public Enum ComponentType
    ctFinding = 1
    ctRecommendation = 2
End Enum

Public Type SBRow
    reportItemID As String
    antwort As String
    Bemerkung As String
    selected As Boolean
    SelectedLevel As Long
End Type

'--- in-memory caches ---
Private dictMaster As Object      ' key: ReportItemID  -> array(Fest, L1, L2, L3, L4)
Private dictOverrides As Object   ' key: ReportItemID|finding|  OR  ReportItemID|recommendation|N  -> text
Private dictSB As Object          ' key: ReportItemID -> SBRow

'=== Public API =====================================================

Public Sub LoadAllCaches()
    Set dictMaster = CreateObject("Scripting.Dictionary")
    Set dictOverrides = CreateObject("Scripting.Dictionary")
    Set dictSB = CreateObject("Scripting.Dictionary")
    LoadMaster
    LoadOverrides
    LoadSB
End Sub

Public Function GetSB(ByVal reportItemID As String) As SBRow
    Dim k$: k = CleanID(reportItemID)
    If dictSB.Exists(k) Then
        Dim a As Variant, s As SBRow
        a = dictSB(k)
        s.reportItemID = CStr(a(1))
        s.antwort = CStr(a(2))
        s.Bemerkung = CStr(a(3))
        s.selected = CBool(a(4))
        s.SelectedLevel = CLng(a(5))
        GetSB = s
    End If
End Function

Public Function GetMasterFinding(ByVal reportItemID As String) As String
    Dim k$: k = CleanID(reportItemID)
    If dictMaster.Exists(k) Then GetMasterFinding = dictMaster(k)(1)
End Function

Public Function GetMasterLevelText(ByVal reportItemID As String, ByVal levelNum As Long) As String
    Dim k$: k = CleanID(reportItemID)
    If dictMaster.Exists(k) And levelNum >= 1 And levelNum <= 4 Then
        GetMasterLevelText = dictMaster(k)(levelNum + 1)
    End If
End Function

Public Function GetResolvedFinding(ByVal reportItemID As String) As String
    Dim k$: k = CleanID(reportItemID)
    Dim ok$: ok = OverrideKey(k, "finding", "")
    If dictOverrides.Exists(ok) Then
        GetResolvedFinding = dictOverrides(ok)
    Else
        GetResolvedFinding = GetMasterFinding(k)
    End If
End Function

Public Function GetResolvedLevelText(ByVal reportItemID As String, ByVal levelNum As Long) As String
    Dim k$: k = CleanID(reportItemID)
    Dim ok$: ok = OverrideKey(k, "recommendation", CStr(levelNum))
    If dictOverrides.Exists(ok) Then
        GetResolvedLevelText = dictOverrides(ok)
    Else
        GetResolvedLevelText = GetMasterLevelText(k, levelNum)
    End If
End Function

Public Sub SaveOverride(ByVal reportItemID As String, ByVal comp As ComponentType, ByVal levelNum As Long, ByVal textBody As String)
    Dim lo As ListObject, i&, k$, compName$, key$
    Set lo = SheetTable("ReportOverrides", "TableOverrides")
    k = CleanID(reportItemID)
    compName = IIf(comp = ctFinding, "Finding", "Recommendation")
    key = OverrideKey(k, LCase$(compName), IIf(comp = ctRecommendation, CStr(levelNum), ""))
    
    ' upsert cache
    dictOverrides(key) = textBody
    
    ' upsert table row
    For i = 1 To lo.ListRows.Count
        With lo.ListRows(i).Range
            If CleanID(CStr(.Cells(1, 1).Value)) = k _
               And LCase$(Trim$(CStr(.Cells(1, 2).Value))) = LCase$(compName) _
               And Trim$(CStr(.Cells(1, 3).Value)) = IIf(comp = ctRecommendation, CStr(levelNum), "") Then
                   .Cells(1, 4).Value = textBody
                   .Cells(1, 5).Value = "active"
                   .Cells(1, 6).Value = Now
                   On Error Resume Next
                   .Cells(1, 8).Value = Environ$("Username") ' EditedBy if present
                   On Error GoTo 0
                   Exit Sub
            End If
        End With
    Next
    With lo.ListRows.Add.Range
        .Cells(1, 1).Value = k
        .Cells(1, 2).Value = compName
        .Cells(1, 3).Value = IIf(comp = ctRecommendation, CStr(levelNum), "")
        .Cells(1, 4).Value = textBody
        .Cells(1, 5).Value = "active"
        .Cells(1, 6).Value = Now
        On Error Resume Next
        .Cells(1, 8).Value = Environ$("Username")
        On Error GoTo 0
    End With
End Sub

Public Sub SaveSBState(ByVal reportItemID As String, ByVal selected As Boolean, ByVal levelNum As Long)
    Dim lo As ListObject, i&
    Set lo = SheetTable("SelbstbeurteilungKunde", "TableSelbstbeurteilung")
    For i = 1 To lo.ListRows.Count
        With lo.ListRows(i).Range
            If CleanID(CStr(.Cells(1, 1).Value)) = CleanID(reportItemID) Then
                .Cells(1, ColumnIndex(lo, "Selected")).Value = selected
                .Cells(1, ColumnIndex(lo, "SelectedLevel")).Value = levelNum
                Exit For
            End If
        End With
    Next
    LoadSB ' keep cache in sync
End Sub

'=== Loaders ========================================================

Private Sub LoadMaster()
    Dim lo As ListObject, r As ListRow, k$, arr(1 To 5) As Variant
    Set lo = SheetTable("MyMaster", "TableMyMaster")
    For Each r In lo.ListRows
        k = CleanID(CStr(r.Range.Cells(1, ColumnIndex(lo, "ReportItemID")).Value))
        If Len(k) > 0 Then
            arr(1) = NzText(r.Range.Cells(1, ColumnIndex(lo, "Feststellung")).Value)
            arr(2) = NzText(r.Range.Cells(1, ColumnIndex(lo, "Level1")).Value)
            arr(3) = NzText(r.Range.Cells(1, ColumnIndex(lo, "Level2")).Value)
            arr(4) = NzText(r.Range.Cells(1, ColumnIndex(lo, "Level3")).Value)
            arr(5) = NzText(r.Range.Cells(1, ColumnIndex(lo, "Level4")).Value)
            dictMaster(k) = arr
        End If
    Next
End Sub

Private Sub LoadOverrides()
    Dim lo As ListObject, r As ListRow, k$, comp$, lvl$
    Set lo = SheetTable("ReportOverrides", "TableOverrides")
    For Each r In lo.ListRows
        k = CleanID(CStr(r.Range.Cells(1, ColumnIndex(lo, "ReportItemID")).Value))
        comp = LCase$(Trim$(CStr(r.Range.Cells(1, ColumnIndex(lo, "Component")).Value)))
        lvl = Trim$(CStr(r.Range.Cells(1, ColumnIndex(lo, "LevelNum")).Value)) ' blank for Finding
        If Len(k) > 0 And comp <> "" Then
            dictOverrides(OverrideKey(k, comp, lvl)) = NzText(r.Range.Cells(1, ColumnIndex(lo, "OverrideText")).Value)
        End If
    Next
End Sub

Private Sub LoadSB()
    Dim lo As ListObject, r As ListRow, k$
    Set lo = SheetTable("SelbstbeurteilungKunde", "TableSelbstbeurteilung")
    
    Dim colID&, colAntw&, colBem&, colSel&, colLvl&
    colID = ColumnIndex(lo, "ReportItemID")
    colAntw = ColumnIndex(lo, "AntwortKunde")
    colBem = ColumnIndex(lo, "BemerkungKunde")
    colSel = ColumnIndex(lo, "Selected")
    colLvl = ColumnIndex(lo, "SelectedLevel")
    
    If colID = 0 Or colAntw = 0 Or colBem = 0 Or colSel = 0 Or colLvl = 0 Then
        Err.Raise 5, , "TableSelbstbeurteilung must contain columns: ReportItemID, AntwortKunde, BemerkungKunde, Selected, SelectedLevel"
    End If
    
    dictSB.RemoveAll
    
    For Each r In lo.ListRows
        k = CleanID(CStr(r.Range.Cells(1, colID).Value))
        If Len(k) > 0 Then
            Dim a(1 To 5) As Variant
            a(1) = k
            a(2) = NzText(r.Range.Cells(1, colAntw).Value)    ' AntwortKunde
            a(3) = NzText(r.Range.Cells(1, colBem).Value)     ' BemerkungKunde
            a(4) = CBool(IIf(NzText(r.Range.Cells(1, colSel).Value) = "", False, r.Range.Cells(1, colSel).Value))
            a(5) = Val(Trim$(CStr(r.Range.Cells(1, colLvl).Value)))
            dictSB(k) = a
        End If
    Next
End Sub
'=== Utilities ======================================================

Private Function SheetTable(ByVal sheetName As String, ByVal tableName As String) As ListObject
    Set SheetTable = ThisWorkbook.Worksheets(sheetName).ListObjects(tableName)
End Function

Private Function ColumnIndex(lo As ListObject, ByVal columnName As String) As Long
    Dim i&: For i = 1 To lo.ListColumns.Count
        If LCase$(Trim$(lo.ListColumns(i).Name)) = LCase$(columnName) Then ColumnIndex = i: Exit Function
    Next
    ColumnIndex = 0
End Function

Private Function OverrideKey(ByVal id As String, ByVal comp As String, ByVal lvl As String) As String
    OverrideKey = LCase$(id & "|" & Trim$(comp) & "|" & Trim$(lvl))
End Function

Public Function CleanID(ByVal s As String) As String
    Dim t$: t = Trim$(s)
    Do While Len(t) > 0 And Right$(t, 1) = ".": t = Left$(t, Len(t) - 1): Loop
    Do While InStr(t, "..") > 0: t = Replace$(t, "..", "."): Loop
    CleanID = t
End Function

Private Function NzText(ByVal v As Variant) As String
    If IsError(v) Or IsNull(v) Then NzText = "" Else NzText = CStr(v)
End Function


--------------------------------------------------

### CLASS MODULE CODE: CRowUI
==================================================
'=================  CRowUI.cls  =================
Option Explicit

' Intent: encapsulate one row's controls + events
' You will pass us the controls we need after cloning the template

' References to controls (late-bound to MSForms)
Public WithEvents ChkInclude As MSForms.CheckBox
Public WithEvents Opt1 As MSForms.OptionButton
Public WithEvents Opt2 As MSForms.OptionButton
Public WithEvents Opt3 As MSForms.OptionButton
Public WithEvents Opt4 As MSForms.OptionButton

Public WithEvents TxtFestEdit As MSForms.TextBox
Public WithEvents TxtLevelEdit As MSForms.TextBox
Public WithEvents ChkUseFestOverride As MSForms.CheckBox
Public WithEvents ChkUseLevelOverride As MSForms.CheckBox
Public WithEvents BtnPromoteMaster As MSForms.CommandButton ' optional (can be Nothing)

' Read-only previews
Public LblLine As MSForms.Label
Public LblID As MSForms.Label
Public LblAntwort As MSForms.Label
Public TxtFestMaster As MSForms.TextBox
Public TxtLevelMaster As MSForms.TextBox

' Data
Public reportItemID As String
Private mLevel As Long
Public Sub Init(ByVal id As String, ByVal antwort As String, ByVal selected As Boolean, ByVal levelNum As Long, _
                ByVal festMaster As String, ByVal levelMaster As String)

    reportItemID = id

    ' Labels
    If Not LblID Is Nothing Then LblID.caption = id
    If Not LblLine Is Nothing Then LblLine.caption = LblLine.caption ' keep whatever caller set
    If Not LblAntwort Is Nothing Then LblAntwort.caption = antwort

    ' Include + level
    If Not ChkInclude Is Nothing Then ChkInclude.Value = selected

    mLevel = IIf(levelNum < 1 Or levelNum > 4, 1, levelNum)
    If Not Opt1 Is Nothing Then Opt1.Value = (mLevel = 1)
    If Not Opt2 Is Nothing Then Opt2.Value = (mLevel = 2)
    If Not Opt3 Is Nothing Then Opt3.Value = (mLevel = 3)
    If Not Opt4 Is Nothing Then Opt4.Value = (mLevel = 4)

    ' Master previews
    If Not TxtFestMaster Is Nothing Then
        TxtFestMaster.Text = festMaster
        TxtFestMaster.Locked = True
    End If

    ' NOTE: your class member is named TxtLevelMAster. Use that exact member.
    If Not TxtLevelMaster Is Nothing Then
        TxtLevelMaster.Text = levelMaster
        TxtLevelMaster.Locked = True
    End If

    ' Edit boxes start empty (or keep any prefilled text)
    ' Checkboxes to save overrides are off by default
    If Not ChkUseFestOverride Is Nothing Then ChkUseFestOverride.Value = False
    If Not ChkUseLevelOverride Is Nothing Then ChkUseLevelOverride.Value = False
End Sub


Private Sub Opt1_Click(): SetLevel 1: End Sub
Private Sub Opt2_Click(): SetLevel 2: End Sub
Private Sub Opt3_Click(): SetLevel 3: End Sub
Private Sub Opt4_Click(): SetLevel 4: End Sub

Private Sub ChkInclude_Click()
    modReportData.SaveSBState reportItemID, ChkInclude.Value, mLevel
End Sub

Private Sub SetLevel(ByVal newLevel As Long)
    mLevel = newLevel
    ' refresh master preview for the chosen level
    TxtLevelMaster.Text = modReportData.GetMasterLevelText(reportItemID, mLevel)
    modReportData.SaveSBState reportItemID, True, mLevel
End Sub

Private Sub TxtFestEdit_Change()
    ' optional: live status indicator; saving is explicit via checkbox toggle below
End Sub

Private Sub TxtLevelEdit_Change()
    ' optional: live status indicator
End Sub

Private Sub ChkUseFestOverride_Click()
    If ChkUseFestOverride.Value Then
        modReportData.SaveOverride reportItemID, ctFinding, 0, TxtFestEdit.Text
    Else
        ' clearing = save empty text (or you can add a routine to delete row)
        modReportData.SaveOverride reportItemID, ctFinding, 0, ""
    End If
End Sub

Private Sub ChkUseLevelOverride_Click()
    If ChkUseLevelOverride.Value Then
        modReportData.SaveOverride reportItemID, ctRecommendation, mLevel, TxtLevelEdit.Text
    Else
        modReportData.SaveOverride reportItemID, ctRecommendation, mLevel, ""
    End If
End Sub

Private Sub BtnPromoteMaster_Click()
    ' optional: copy override into MyMaster (left to your governance)
    ' You can implement a modReportData.PromoteToMaster(...) when ready.
    MsgBox "Promote-to-Master not wired yet.", vbInformation
End Sub


--------------------------------------------------

